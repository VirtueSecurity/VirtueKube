package com.nickcoblentz.kubepentest.utils

import com.google.gson.Gson
import com.nickcoblentz.kubepentest.commands.PackageVersionSource
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.coroutines.runBlocking
import java.io.File
import java.io.IOException
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.util.concurrent.TimeUnit

/**
 * Top-level wrapper for the entire JSON response from the API.
 */
data class ApiProductResponse(
    val result: List<ProductData>
)

/**
 * Wrapper for the "result" object in the JSON, which contains product details.
 */
data class ProductData(
    val name: String,
    val releases: List<ProductCycle>
)

/**
 * Represents a single version cycle for a product from the endoflife.date API.
 * Fields are mapped from the "releases" array in the new JSON structure.
 */
data class ProductCycle(
    val name: String,
    val releaseDate: String,
    val eolFrom: String?,
    val isEol: Boolean,
    val latest: LatestVersionInfo,
    val isLts: Boolean,
    val isMaintained: Boolean
)

/**
 * Represents the nested "latest" object within a release cycle.
 */
data class LatestVersionInfo(
    val name: String,
    val date: String,
    val link: String
)


/**
 * Manages fetching, caching, and querying end-of-life data for a specific product.
 *
 * @param productName The name of the product to track (e.g., "nginx", "python").
 * @param cacheDir The directory where the cache file will be stored.
 */
class ProductEOLChecker(private val productName: String) {

    private val cacheDir = File(System.getProperty("java.io.tmpdir"), "eol_cache")
    val cacheFile = File(cacheDir, CACHE_FILE_NAME)

    // Ktor HTTP client using the CIO engine
    private val client = HttpClient(CIO)
    private val gson = Gson()

    private var productCycles: List<ProductCycle> = emptyList()

    companion object {
        private val DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd")
        private const val CACHE_DURATION_DAYS = 7L
        private const val CACHE_FILE_NAME = "all-products-eol-cache.json"
    }

    init {

        println("Cache file will be: ${cacheFile.absolutePath}")
        // Ensure the cache directory exists
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
        // Use runBlocking to call the suspend function from the constructor
        runBlocking {
            loadData()
        }
    }

    fun productFound() = productCycles.isNotEmpty()

    /**
     * Loads the product EOL data. It first checks if a recent cache file exists.
     * If the cache is stale or absent, it downloads fresh data from the API.
     * This is a suspend function as it performs network I/O.
     */
    private suspend fun loadData() {

        if (isCacheStale()) {
            println("Cache is stale or not found. Downloading new data for all products...")
            try {
                downloadAndCacheData()
            } catch (e: Exception) {
                println("Error downloading new data: ${e.message}")
            }
        }

        println("Loading all products data from cache.")

        val allProducts: List<ProductData> = loadDataFromCache()

        // Find the specific product from the full list
        val specificProductData = allProducts.find { it.name == productName }
        if (specificProductData != null) {
            this.productCycles = specificProductData.releases
        } else {
            println("Warning: Could not find data for product '$productName' in the dataset.")
            this.productCycles = emptyList()
        }
    }

    /**
     * Downloads the product data from the endoflife.date API using Ktor
     * and saves it to the cache file.
     */
    @Throws(IOException::class)
    private suspend fun downloadAndCacheData() {
        val response: HttpResponse = client.get("https://endoflife.date/api/v1/products/full")

        if (response.status.value !in 200..299) {
            throw IOException("Unexpected code ${response.status}")
        }

        val responseBody = response.bodyAsText()
        cacheFile.writeText(responseBody)
    }

    public fun getProductEOLLink() = "https://endoflife.date/$productName"

    /**
     * Loads the product cycle data from the JSON cache file.
     * It now expects the data to be in the new nested structure.
     * @return A list of ProductCycle objects.
     */
    private fun loadDataFromCache(): List<ProductData> {
        if (!cacheFile.exists()) return emptyList()
        val jsonText = cacheFile.readText()
        return try {
            // Deserialize the JSON into our new top-level response object
            val apiResponse = gson.fromJson(jsonText, ApiProductResponse::class.java)
            apiResponse.result
        } catch (e: Exception) {
            println("Error parsing JSON structure. Error: ${e.message}\n ${e.stackTraceToString()}")
            emptyList() // Return empty list on parsing failure
        }
    }

    /**
     * Checks if the cache file is older than the defined CACHE_DURATION_DAYS.
     * @return True if the cache is stale or doesn't exist, false otherwise.
     */
    private fun isCacheStale(): Boolean {
        if (!cacheFile.exists()) return true
        val lastModified = cacheFile.lastModified()
        val staleTime = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(CACHE_DURATION_DAYS)
        return lastModified < staleTime
    }

    /**
     * Finds a product cycle that matches the given version string.
     * It matches based on the major/minor version (e.g., "1.21.3" matches cycle "1.21").
     *
     * @param version The full version string (e.g., "1.21.3").
     * @return The matching ProductCycle, or null if not found.
     */
    private fun findCycleForVersion(version: String): ProductCycle? {
        return productCycles.find { cycle ->
            // Match if the version starts with the cycle string.
            // This handles cases like version "3.9.5" matching cycle "3.9".
            if(version.substringBefore("-").count { it == '.' } > cycle.name.count{ it == '.' })
                version.startsWith("${cycle.name}.")
            else
                version.startsWith(cycle.name)
        }
    }

    /**
     * Checks if a specific version has reached its end of life.
     *
     * @param version The product version to check (e.g., "1.20.1").
     * @return True if the version is past its EOL date, false otherwise. Returns null if the version cycle is not found.
     */
    fun hasReachedEOL(version: String): Boolean {
        val cycle = findCycleForVersion(version) ?: return false
        return isDateInPast(cycle.eolFrom) ?: false
    }

    /**
     * Checks if a specific version is still under security support.
     *
     * @param version The product version to check (e.g., "1.22.0").
     * @return True if the version is still within its security support window, false otherwise. Returns null if the cycle is not found.
     */
    fun isInSecuritySupport(version: String): Boolean? {
        val cycle = findCycleForVersion(version) ?: return null
        val eolDateInPast = isDateInPast(cycle.eolFrom)
        return when (eolDateInPast) {
            true -> false // EOL date is in the past, so no more security support.
            false -> true // EOL date is in the future, so it still has security support.
            null -> true  // No EOL date defined, assume it's indefinitely supported.
        }
    }

    /**
     * Checks if a specific version is in active support.
     * This is interpreted as not being discontinued and not having passed its support date.
     *
     * @param version The product version to check.
     * @return True if the version is considered actively supported, false otherwise. Returns null if the cycle is not found.
     */
    fun isInActiveSupport(version: String): Boolean? {
        val cycle = findCycleForVersion(version) ?: return null
        // The 'isMaintained' flag directly tells us if the version is in active support.
        return cycle.isMaintained
    }

    fun isOutOfDate(version: String): Boolean {
        val strippedVersion = version.substringBefore("-")
        val cycle = findCycleForVersion(strippedVersion)
        return cycle != null && cycle.latest.name.split(".").last().toInt() > strippedVersion.split(".").last().toInt()
    }

    fun getLatestVersion(version: String): String? {
        val cycle = findCycleForVersion(version)
        return cycle?.latest?.name
    }

    /**
     * Helper function to parse a date string and check if it's in the past.
     * @param dateString The date string to parse (e.g., "2025-01-01").
     * @return True if the date is in the past, false if it's in the future.
     * Returns null if the string is null or cannot be parsed.
     */
    private fun isDateInPast(dateString: String?): Boolean? {
        if (dateString == null) return null
        return try {
            val date = LocalDate.parse(dateString, DATE_FORMATTER)
            date.isBefore(LocalDate.now())
        } catch (e: Exception) {
            println("Warning: Could not parse date string '$dateString'")
            null
        }
    }
}

// --- Example Usage ---
// main is now a suspend function to properly close the Ktor client.
suspend fun main() {

    // Create a checker for nginx
//    val nginxChecker = ProductEOLChecker("nginx")
//
//    // --- Check different versions of Nginx ---
//    val oldVersion = "1.27.2"
//    val securitySupportVersion = "1.28.1"
//    val activeVersion = "1.29.0" // Assuming this is the current stable version
//
//    println("\n--- Checking Nginx Versions ---")
//
//    // Check EOL status
//    println("Has version $oldVersion reached EOL? ${nginxChecker.hasReachedEOL(oldVersion)}")
//    println("Has version $securitySupportVersion reached EOL? ${nginxChecker.hasReachedEOL(securitySupportVersion)}")
//    println("Has version $activeVersion reached EOL? ${nginxChecker.hasReachedEOL(activeVersion)}")
//
//    println()
//
//    // Check Security Support status
//    println("Is version $oldVersion in security support? ${nginxChecker.isInSecuritySupport(oldVersion)}")
//    println("Is version $securitySupportVersion in security support? ${nginxChecker.isInSecuritySupport(securitySupportVersion)}")
//    println("Is version $activeVersion in security support? ${nginxChecker.isInActiveSupport(activeVersion)}")
//
//    println()
//
//    // Check Active Support status
//    println("Is version $oldVersion in active support? ${nginxChecker.isInActiveSupport(oldVersion)}")
//    println("Is version $securitySupportVersion in active support? ${nginxChecker.isInActiveSupport(securitySupportVersion)}")
//    println("Is version $activeVersion in active support? ${nginxChecker.isInActiveSupport(activeVersion)}")
//
//    println("\n--- Second Run (should use cache) ---")
//    val nginxChecker2 = ProductEOLChecker("nginx")
//    println("Is version $activeVersion in active support? ${nginxChecker2.isInActiveSupport(activeVersion)}")


    val versionChecker = ProductEOLChecker("php")

    // --- Check different versions of Nginx ---
    val oldVersion = "8.0.29"
    val securitySupportVersion = "8.2.28"
    val activeVersion = "8.3" // Assuming this is the current stable version

    println("\n--- Checking Versions ---")

    // Check EOL status
    println("Has version $oldVersion reached EOL? ${versionChecker.hasReachedEOL(oldVersion)}")
    println("Has version $securitySupportVersion reached EOL? ${versionChecker.hasReachedEOL(securitySupportVersion)}")
    println("Has version $activeVersion reached EOL? ${versionChecker.hasReachedEOL(activeVersion)}")

    println()

    // Check Security Support status
    println("Is version $oldVersion in security support? ${versionChecker.isInSecuritySupport(oldVersion)}")
    println("Is version $securitySupportVersion in security support? ${versionChecker.isInSecuritySupport(securitySupportVersion)}")
    println("Is version $activeVersion in security support? ${versionChecker.isInActiveSupport(activeVersion)}")

    println()

    // Check Active Support status
    println("Is version $oldVersion in active support? ${versionChecker.isInActiveSupport(oldVersion)}")
    println("Is version $securitySupportVersion in active support? ${versionChecker.isInActiveSupport(securitySupportVersion)}")
    println("Is version $activeVersion in active support? ${versionChecker.isInActiveSupport(activeVersion)}")

    // Check Out Of Date status
    println("Is version $oldVersion out of date? ${versionChecker.isOutOfDate(oldVersion)} (latest: ${versionChecker.getLatestVersion(oldVersion)})")
    println("Is version $securitySupportVersion out of date? ${versionChecker.isOutOfDate(securitySupportVersion)} (latest: ${versionChecker.getLatestVersion(securitySupportVersion)})")
    println("Is version $activeVersion out of date? ${versionChecker.isOutOfDate(activeVersion)} (latest: ${versionChecker.getLatestVersion(activeVersion)})")

}

val productVersionLookup = mapOf<PackageVersionSource,Map<Regex,String>> (
    PackageVersionSource.ENVIRONMENT_VARIABLE to mapOf(
        "ALPINE_VERSION".toRegex() to "alpine",
        "GOLANG_VERSION".toRegex() to "go",
        "HTTPD_VERSION".toRegex() to "apache-http-server",
        "JAVA_VERSION".toRegex() to "java",
        "JENKINS_VERSION".toRegex() to "jenkins",
        "MARIADB_VERSION".toRegex() to "mariadb",
        "MONGO_VERSION".toRegex() to "mongo",
        "MYSQL_VERSION".toRegex() to "mysql",
        "NGINX_VERSION".toRegex() to "nginx",
        "NJS_VERSION".toRegex() to "njs",
        "PERL_VERSION".toRegex() to "perl",
        "PHP_VERSION".toRegex() to "php",
        "POSTGRES_VERSION".toRegex() to "postgres",
        "PYTHON_VERSION".toRegex() to "python",
        "REDIS_VERSION".toRegex() to "redis",
        "RUBY_VERSION".toRegex() to "ruby",
        "TOMCAT_VERSION".toRegex() to "tomcat",
        "MEMCACHED_VERSION".toRegex() to "memcached",
        "REDIS_DOWNLOAD_URL".toRegex() to "redis",
        "NODE_VERSION".toRegex() to "node",
        "DJANGO_VERSION".toRegex() to "django",
        "JETTY_VERSION".toRegex() to "eclipse-jetty",
    ),
    PackageVersionSource.BUILD_HISTORY to mapOf(
        "alpine-.*-([0-9]+.[0-9]+.[0-9]+)".toRegex() to "alpine-linux",
        "traefik_v?([0-9]+.[0-9]+.[0-9]+)".toRegex() to "traefik",
        "docker-([0-9]+.[0-9]+.[0-9]+)".toRegex() to "docker-engine",
        "BusyBox ([0-9]+.[0-9]+.[0-9]+)".toRegex() to "busybox",
        "MAVEN_VERSION".toRegex() to "maven",
    ),
    PackageVersionSource.IMAGE_NAME to mapOf(
        "cert-manager".toRegex() to "cert-manager",
        "prometheus".toRegex() to "prometheus",
        "traefik".toRegex() to "traefik",
        "amazonlinux".toRegex() to "amazon-linux",
        "amazoncorretto".toRegex() to "amazon-corretto",

    ),
    PackageVersionSource.IMAGE_TAG to mapOf(
        "cert-manager".toRegex() to "cert-manager",
        "prometheus".toRegex() to "prometheus",
        "traefik".toRegex() to "traefik",
        "amazonlinux".toRegex() to "amazon-linux",
        "amazoncorretto".toRegex() to "amazon-corretto",
    )
)

//fun productVersionFromKubeSourceToEolChecker(lookupValue : String, source : PackageVersionSource) : Pair<Regex,String>? {
//    productVersionLookup[source]?.keys?.find { it.containsMatchIn(lookupValue) }?.let {
//        return Pair(it,productVersionLookup[source]?.get(it)!!)
//    }
//    return null
//}

fun endOfLifeProductVersionPair(lookupValue : String, source : PackageVersionSource) : Pair<Regex,String>? {
    productVersionLookup[source]?.keys?.find {
        it.containsMatchIn(lookupValue)
    }?.let {
        return Pair(it,productVersionLookup[source]?.get(it)!!)
    }

    if(source == PackageVersionSource.ENVIRONMENT_VARIABLE) {
        val versionRegex = "([a-zA-Z]+)_VERSION".toRegex()
        versionRegex.find(lookupValue)?.let { matchResult ->
            if(matchResult.groups.size > 1)
                matchResult.groups[1]?.let {
                    return Pair(versionRegex,it.value.lowercase())
                }

        }
    }

    return null
}