package com.nickcoblentz.kubepentest.utils

import com.fasterxml.jackson.annotation.JsonProperty
import com.nickcoblentz.data.CsvColumnMapping
import io.fabric8.kubernetes.api.model.Secret
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import java.io.ByteArrayInputStream
import java.util.*
import java.util.zip.GZIPInputStream

/**
 * Data class to hold parsed Helm release information.
 */
data class HelmRelease(
    @CsvColumnMapping(name = "name", order = 1)
    @JsonProperty("Name")
    val name: String?,

    @CsvColumnMapping(name = "version", order = 2)
    @JsonProperty("Version")
    val version: String?,

    @CsvColumnMapping(name = "Application Version", order = 3)
    @JsonProperty("appVersion")
    val appVersion: String?,

    @CsvColumnMapping(name = "Chart Name", order = 4)
    @JsonProperty("chartName")
    val chartName: String?,

    @CsvColumnMapping(name = "Values", order = 5)
    @JsonProperty("values")
    val values: String?
)

/**
 * Helper function to decode and decompress Helm secret data.
 */
fun decodeHelmSecretData(secret: Secret): ByteArray? {
    val b64EncodedCompressedData = secret.data["release"]
    if (b64EncodedCompressedData == null) {
        System.err.println("Secret ${secret.metadata.name} does not contain 'release' data.")
        return null
    }

    try {
        val compressedData = Base64.getDecoder().decode(b64EncodedCompressedData)
        val compressedData2 = Base64.getDecoder().decode(compressedData)
        val gzipInputStream = GZIPInputStream(ByteArrayInputStream(compressedData2))
        return gzipInputStream.readBytes()
    } catch (e: Exception) {
        System.err.println("Failed to decode and decompress Helm release data from secret ${secret.metadata.name}: ${e.message}")
        return null
    }
}

/**
 * Helper function to parse Helm release data (proto-encoded).
 */
fun parseHelmReleaseData(data: ByteArray): HelmRelease? {
    try {
        // Helm release data is encoded using Protobuf.
        // We'll use a simple regex to extract the relevant parts for demonstration,
        // but for robust parsing, you'd typically use protobuf-java and the Helm proto definitions.
        val dataString = String(data)
        val helmJson = Json.parseToJsonElement(dataString).jsonObject

        val name = helmJson.jsonObject["name"]?.jsonPrimitive?.content
        val version = helmJson.jsonObject["chart"]?.jsonObject["metadata"]?.jsonObject["version"]?.jsonPrimitive?.content
        val appVersion = helmJson.jsonObject["chart"]?.jsonObject["metadata"]?.jsonObject["appVersion"]?.jsonPrimitive?.content
        val chartName = helmJson.jsonObject["chart"]?.jsonObject["metadata"]?.jsonObject["name"]?.jsonPrimitive?.content
        val values = helmJson.jsonObject["config"]?.toString()
        return HelmRelease(name, version, appVersion, chartName, values)

    } catch (e: Exception) {
        System.err.println("Failed to parse Helm release data: ${e.message}")
        return null
    }
}