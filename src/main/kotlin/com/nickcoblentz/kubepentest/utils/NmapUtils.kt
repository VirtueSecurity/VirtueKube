package com.nickcoblentz.kubepentest.utils

import com.fasterxml.jackson.annotation.JsonProperty
import com.nickcoblentz.data.CsvColumnMapping
import io.fabric8.kubernetes.api.model.HasMetadata
import io.fabric8.kubernetes.api.model.Node
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.Service
import org.w3c.dom.Document
import org.w3c.dom.Element
import javax.xml.parsers.DocumentBuilderFactory

data class NMapKubeResourceEntry (

    @CsvColumnMapping(name = "Cluster Namespace", order = 1)
    var resourceNamespace : String = "",

    @CsvColumnMapping(name = "Cluster Resource Name", order = 2)
    var resourceName : String = "",

    @CsvColumnMapping(name = "Cluster Resource Type", order = 3)
    var resourceType : String = "",

    @CsvColumnMapping(name = "IP Address", order = 4)
    val address : String,

    @CsvColumnMapping(name = "Address Type", order = 5)
    val addressType : String,

    @CsvColumnMapping(name = "Hostnames", order = 6)
    val hostnames : List<String>,

    @CsvColumnMapping(name = "Port", order = 7)
    val port : String,

    @CsvColumnMapping(name = "Protocol", order = 8)
    val protocol : String,

    @CsvColumnMapping(name = "Service", order = 9)
    val service : String,

    @CsvColumnMapping(name = "Product", order = 10)
    val serviceProduct : String,

    @CsvColumnMapping(name = "Service Version", order = 11)
    val serviceVersion : String,

    @CsvColumnMapping(name = "Extra Info", order = 12)
    val serviceExtraInfo : String,

    @CsvColumnMapping(name = "Tunnel?", order = 13)
    val serviceTunnel : String,



)

fun parseNmapXml(nmapXml: String) : MutableList<NMapKubeResourceEntry> {
    val factory = DocumentBuilderFactory.newInstance()
    val builder = factory.newDocumentBuilder()
    val document = builder.parse(nmapXml.byteInputStream())

    val nmapEntries = mutableListOf<NMapKubeResourceEntry>()

    val hostElements = document.getElementsByTagName("host")
    for (i in 0 until hostElements.length) {
        var ipAddress = ""
        val hostnames = mutableListOf<String>()
        var portId = ""
        var protocol = ""
        var serviceName = ""
        var serviceProduct = ""
        var serviceExtra = ""
        var serviceTunnel = ""
        var addressType = ""
        var serviceVersion = ""

        val hostElement = hostElements.item(i) as Element
        val addressElements = hostElement.getElementsByTagName("address")


        for (j in 0 until addressElements.length) {
            val addressElement = addressElements.item(j) as Element
            addressType = addressElement.getAttribute("addrtype")
            ipAddress = addressElement.getAttribute("addr")
            break

        }


        val hostnameElements = hostElement.getElementsByTagName("hostname")
        if (hostnameElements.length > 0) {
            hostnames.add( (hostnameElements.item(0) as Element).getAttribute("name"))
        }

        val portElements = hostElement.getElementsByTagName("port")

        for (j in 0 until portElements.length) {
            val portElement = portElements.item(j) as Element

            // Check if port is open
            val stateElement = portElement.getElementsByTagName("state").item(0) as Element
            if (stateElement.getAttribute("state") != "open") {
                continue
            }

            portId = portElement.getAttribute("portid")
            protocol = portElement.getAttribute("protocol")

            // Get service information
            val serviceElements = portElement.getElementsByTagName("service")
            if (serviceElements.length > 0) {
                val serviceElement = serviceElements.item(0) as Element
                serviceName = serviceElement.getAttribute("name")
                serviceProduct = serviceElement.getAttribute("product")
                serviceExtra = serviceElement.getAttribute("extrainfo")
                serviceTunnel = serviceElement.getAttribute("tunnel")
                serviceVersion = serviceElement.getAttribute("version")
            }
        }
        nmapEntries.add(NMapKubeResourceEntry(
            address = ipAddress,
            addressType = addressType,
            hostnames = hostnames,
            port = portId,
            protocol = protocol,
            service = serviceName,
            serviceProduct = serviceProduct,
            serviceVersion = serviceVersion,
            serviceExtraInfo = serviceExtra,
            serviceTunnel = serviceTunnel
        ))

    }

    return nmapEntries
}

fun coorelateNmapResultsWithKubernetesResources(nmapEntries: MutableList<NMapKubeResourceEntry>, kubernetesResources: MutableList<HasMetadata>, importExportUtils: ImportExportUtils) {

    val pods = mutableListOf<Pod>()
    val nodes = mutableListOf<io.fabric8.kubernetes.api.model.Node>()
    val services = mutableListOf<io.fabric8.kubernetes.api.model.Service>()

    kubernetesResources.forEach { resource ->
        //println("parsing resources")

        try {
            when (resource.kind) {
                "Node" -> nodes.add(importExportUtils.unmarshal<Node>(resource))
                "Pod" -> pods.add(importExportUtils.unmarshal<Pod>(resource))
                "Service" -> services.add(importExportUtils.unmarshal<Service>(resource))
                else -> {}
            }
        }
        catch(e: Exception) {
            println("failed to parse resource: ${resource.kind} ${e.message}\n${e.stackTraceToString()}")
        }

    }
    //println("finished parsing resources")

    nmapEntries.forEach { entry ->
        //println("node")
        val node = nodes.find { node ->
            node.status.addresses.find { address ->
                address.address == entry.address
            } != null
        }
        //println("node2")
        if(node != null) {
            entry.resourceName = node.metadata.name
            entry.resourceType = "Node"
        }
        else {
            //println("service")
            val service = services.find { service ->
                service.spec.clusterIPs.find {clusterIP ->
                    clusterIP == entry.address
                } != null
            }
            //println("service2")
            if(service != null) {
                entry.resourceName = service.metadata.name
                entry.resourceType = "Service"
                entry.resourceNamespace = service.metadata.namespace
            }

            else {
                //println("pod")
                val pod = pods.find { pod ->
                    pod.status.podIP == entry.address
                }
                //println("pod2")
                if(pod != null) {
                    entry.resourceName = pod.metadata.name
                    entry.resourceType = "Pod"
                    entry.resourceNamespace = pod.metadata.namespace

                }
            }
        }




    }
    //println("node/service/pod done")
}

fun extractHttpsUrls(nmapEntries: MutableList<NMapKubeResourceEntry>): List<String> {

    val urls = mutableListOf<String>()

    nmapEntries.forEach { entry ->
        if (entry.service == "https" || entry.service == "http") {
            urls.add(extractHTTPUrl(entry.address, entry.port, entry.service))
            entry.hostnames.forEach { hostname ->
                urls.add(extractHTTPUrl(hostname, entry.port, entry.service))
            }
        }
    }

    return urls
}

fun extractHTTPUrl(addressOrHostname: String, port: String, protocol: String): String {
    return "$protocol://$addressOrHostname:$port"
}