package com.nickcoblentz.kubepentest.commands

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.kubepentest.models.KubePentestContext
import java.io.BufferedReader
import java.nio.file.FileVisitResult
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.SimpleFileVisitor
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import java.nio.file.attribute.BasicFileAttributes
import kotlin.io.path.createDirectories
import kotlin.io.path.exists
import kotlin.io.path.readText

class GenerateKustomizeTestCases : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = "${(TextColors.gray)("(offline)")} Generate manifests from kustomize test cases and validate with kubeconform"


    private val config by requireObject<KubePentestContext>()

    init { installMordantMarkdown() }

    override fun run() {
        val kustomizeSourceDir = config.testCaseDirectoryPath ("kustomize")
        if (!kustomizeSourceDir.exists()) {
            config.prettyLogger.printlnWarning(title = "Kustomize", message = "Base directory ${kustomizeSourceDir.toAbsolutePath()} does not exist. Nothing to do.")
            return
        }
        val outputDir = config.testCaseResultsDirectoryPath("kustomize")
        outputDir.createDirectories()

        // Iterate through subdirectories containing kustomization.yaml
        Files.newDirectoryStream(kustomizeSourceDir) { Files.isDirectory(it) }.use { dirs ->
            dirs.forEach { testDir ->
                val kust = testDir.resolve("kustomization.yaml")
                if (Files.exists(kust)) {
                    generateFor(testDir, outputDir)
                    maybeGenerateInitContainerVariant(testDir, outputDir)
                }
            }
        }
    }

    private fun kustomizeAndValidate(sourceDir: Path, outFile: Path, displayName: String): Boolean {
        return try {
            val pb = ProcessBuilder("kubectl", "kustomize", "--load-restrictor=LoadRestrictionsNone", sourceDir.toAbsolutePath().toString())
            val process = pb.start()
            val manifest = process.inputStream.bufferedReader().use(BufferedReader::readText)
            val err = process.errorStream.bufferedReader().use(BufferedReader::readText)
            val code = process.waitFor()
            if (code != 0) {
                config.prettyLogger.printlnError(title = "kubectl kustomize failed ($displayName)", message = err)
                false
            } else {
                Files.writeString(outFile, manifest, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)
                config.prettyLogger.printlnInfo(title = "Generated", message = outFile.toAbsolutePath().toString())

                val pb2 = ProcessBuilder("kubeconform", "-strict", "-summary", outFile.toAbsolutePath().toString())
                val p2 = pb2.start()
                val vOut = p2.inputStream.bufferedReader().use(BufferedReader::readText)
                val vErr = p2.errorStream.bufferedReader().use(BufferedReader::readText)
                val vCode = p2.waitFor()
                if (vCode != 0) {
                    config.prettyLogger.printlnError(title = "kubeconform validation failed ($displayName)", message = vOut + "\n" + vErr)
                    false
                } else {
                    config.prettyLogger.printlnSuccess(title = "Validated", message = "$displayName passed kubeconform")
                    true
                }
            }
        } catch (e: Exception) {
            config.prettyLogger.printlnError(title = "Error", message = "${e.message}")
            false
        }
    }

    private fun generateFor(testDir: Path, outputRoot: Path) {
        val testName = testDir.fileName.toString()
        val outFile = outputRoot.resolve("$testName.yaml")
        kustomizeAndValidate(testDir, outFile, testName)
    }

    private fun maybeGenerateInitContainerVariant(testDir: Path, outputRoot: Path) {
        val kust = testDir.resolve("kustomization.yaml")
        val original = try { Files.readString(kust) } catch (e: Exception) { return }
        if (!original.contains("/spec/containers")) return

        // Replace containers path with initcontainers and update annotations to indicate init container
        var modified = original.replace("/spec/containers", "/spec/initContainers")
        // Append " (init container)" to test-title and test-description values
        val titlePattern = Regex(
            """(?m)(/metadata/annotations/virtuekube\.io~1test-title\s*\n\s*value:\s*")([^"]*)"""
        )
        val descPattern = Regex(
            """(?m)(/metadata/annotations/virtuekube\.io~1test-description\s*\n\s*value:\s*")([^"]*)"""
        )
        modified = titlePattern.replace(modified) { mr -> mr.groupValues[1] + mr.groupValues[2] + " (init container)" }
        modified = descPattern.replace(modified) { mr -> mr.groupValues[1] + mr.groupValues[2] + " (init container)" }

        // Create a temporary sibling directory to preserve relative paths like ../base
        val parent = testDir.parent
        val tempDir = Files.createTempDirectory(parent, testDir.fileName.toString() + "-initcontainer-")
        try {
            Files.writeString(tempDir.resolve("kustomization.yaml"), modified, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)
            val testName = testDir.fileName.toString() + "-initcontainer"
            val outFile = outputRoot.resolve("$testName.yaml")

            val ok = kustomizeAndValidate(tempDir, outFile, testName)
            if (!ok) {
                // Provide visibility into the generated temp kustomization on failure
                runCatching { config.prettyLogger.printlnInfo(title = "Kustomize", message = tempDir.resolve("kustomization.yaml").readText(Charsets.UTF_8)) }
            }
        } finally {
            // Clean up temp directory
            try {
                Files.walkFileTree(tempDir, object : SimpleFileVisitor<Path>() {
                    override fun visitFile(file: Path, attrs: BasicFileAttributes?): FileVisitResult {
                        Files.deleteIfExists(file)
                        return FileVisitResult.CONTINUE
                    }
                    override fun postVisitDirectory(dir: Path, exc: java.io.IOException?): FileVisitResult {
                        Files.deleteIfExists(dir)
                        return FileVisitResult.CONTINUE
                    }
                })
            } catch (_: Exception) { /* ignore cleanup errors */ }
        }
    }
}
