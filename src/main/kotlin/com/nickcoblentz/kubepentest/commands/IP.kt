package com.nickcoblentz.kubepentest.commands

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.boolean
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.kubepentest.models.IPAndPort
import com.nickcoblentz.kubepentest.models.IngressClass
import com.nickcoblentz.kubepentest.models.KubePentestContext
import io.fabric8.kubernetes.api.model.HasMetadata
import io.fabric8.kubernetes.api.model.Node
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.Service
import io.fabric8.kubernetes.api.model.discovery.v1.EndpointSlice
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import java.io.File
import java.nio.file.Files
import kotlin.io.path.absolutePathString

/**
 * Command to dump all IP addresses associated with pods, nodes, services, and ingressroutes.
 */
class IP : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = "${(TextColors.gray)("(offline)")} Dump all IP Addresses associated with pods, nodes, services, and ingressroutes"
    private val dumpOption by option("-d", "--dump", help = "Dump").boolean().default(true)
    private val config by requireObject<KubePentestContext>()

    val nodeIPAndPorts = mutableListOf<IPAndPort>()
    val podIPAndPorts = mutableListOf<IPAndPort>()
    val serviceDNSAndPorts = mutableListOf<IPAndPort>()
    val podIPandPortsMap = mutableMapOf<String, MutableList<Int>>()
    var podIPSet = mutableSetOf<String>()
    var serviceIPSet = mutableSetOf<String>()
    var serviceDNSSet = mutableSetOf<String>()
    val serviceIPAndPortsMap = mutableMapOf<String, MutableList<Int>>()
    val ingressRoutesMap = mutableMapOf<String, IPAndPort>()
    val ingressClasses = mutableListOf<IngressClass>()
    val endpointSlices = mutableListOf<EndpointSlice>()

    init {
        this.installMordantMarkdown()
    }

    override fun run() {

        val deserializeResources = config.importExportUtils.deserializeFromFile(config.allJSONFilePath().toString())

        extractTraefikInformation(deserializeResources)

        deserializeResources.forEach { resource ->
            when (resource.kind) {
                "Node" -> handleNode(resource)
                "Pod" -> handlePod(resource)
                "Service" -> handleService(resource)
                "IngressRoute" -> handleIngressRoute(resource)
            }
        }

        podIPSet = podIPAndPorts.map { it.ip.trim() }.toMutableSet()
        if (dumpOption) {
            Files.writeString(
                config.ipsDataDirectoryPath("podips.txt"),
                podIPSet.joinToString("\n")
            )
        }

        podIPAndPorts.forEach { podIPAndPort ->
            podIPAndPort.port?.let { port ->
                if (port > 0) {
                    podIPandPortsMap.putIfAbsent(podIPAndPort.ip, mutableListOf<Int>())
                    podIPandPortsMap[podIPAndPort.ip]?.add(port)
                }
            }
        }

        if (dumpOption) {
            var path = config.ipsDataDirectoryPath("podipandports.txt")
            File(path.toString()).printWriter().use { writer ->
                podIPandPortsMap.map { it -> writer.println("${it.key}\t${it.value.joinToString(",")}") }
            }

            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")

            path = config.ipsDataDirectoryPath( "nodeips.txt")
            File(path.toString()).printWriter().use { writer ->
                nodeIPAndPorts.forEach { writer.println(it.ip) }
            }

            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")

            path = config.ipsDataDirectoryPath("podips.txt")
            Files.writeString(
                path,
                podIPSet.joinToString("\n")
            )

            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")
            path = config.ipsDataDirectoryPath("ingressrouteipsandports.txt")
            File(path.toString()).printWriter().use { writer ->
                ingressRoutesMap.forEach { (key, value) ->
                    writer.println("$key\t${value.ip}\t${value.port}")
                }
            }

            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")
        }

        serviceDNSSet = serviceDNSAndPorts.map { it.dns.trim() }.toMutableSet()
        serviceIPSet = serviceDNSAndPorts.map { it.dns.trim() }.toMutableSet()
        if (dumpOption) {
            var path = config.ipsDataDirectoryPath("servicedns.txt")
            Files.writeString(
                path,
                serviceDNSSet.joinToString("\n")
            )
            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")

            path = config.ipsDataDirectoryPath("serviceips.txt")
            Files.writeString(
                path,
                serviceIPSet.joinToString("\n")
            )
            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")
        }

        serviceDNSAndPorts.forEach { serviceIPAndPort ->
            serviceIPAndPort.port?.let { port ->
                if (port > 0) {
                    serviceIPAndPortsMap.putIfAbsent(serviceIPAndPort.dns, mutableListOf<Int>())
                    serviceIPAndPortsMap[serviceIPAndPort.dns]?.add(port)
                }
            }
        }

        if (dumpOption) {
            var path = config.ipsDataDirectoryPath("servicednsandports.txt")

            File(path.toString()).printWriter()
                .use { writer ->
                    serviceIPAndPortsMap.map { it -> writer.println("${it.key}\t${it.value.joinToString(",")}") }
                }

            config.prettyLogger.printlnSuccess(message = "Wrote to ${path.absolutePathString()}")

            config.prettyLogger.printlnWarning(
                title = "Caution",
                message = "ingress, ingressRouteTcp, and ingressRouteUdp are not yet supported. Run `kubectl get` for each of those resources"
            )
        }
    }

    private fun extractTraefikInformation(resources: MutableList<HasMetadata>) {
        resources.filter { it.kind == "IngressClass" }.forEach { ingressClasses.add(IngressClass(name = it.metadata.name)) }
        resources.filter {
            it.kind == "EndpointSlice"
                    && it.metadata.labels.containsKey("app.kubernetes.io/name")
                    && it.metadata.labels.getValue("app.kubernetes.io/name").equals("traefik", true)
        }
            .forEach { endpointSlices.add(config.importExportUtils.unmarshal<EndpointSlice>(it)) }
    }

    private fun lookupTraefikPort(portString: String): Int {
        endpointSlices.forEach { slice ->
            slice.ports.forEach { portsSpec ->
                if (portsSpec.name.equals(portString))
                    return portsSpec.port
            }
        }
        return 0
    }

    private fun lookupTraefikIPs(): List<String> {
        val result = mutableListOf<String>()
        endpointSlices.forEach {
            it.endpoints.forEach {
                it.addresses.forEach {
                    result.add(it)
                }
            }
        }
        return result
    }

    private fun handleIngressRoute(resource: HasMetadata) {
        val ingressRouteJSON = Json.parseToJsonElement(config.importExportUtils.serializeToString(resource)).jsonObject
        val ports = mutableListOf<Int>()
        val ips = lookupTraefikIPs()
        ingressRouteJSON.jsonObject["spec"]?.jsonObject["entryPoints"]?.jsonArray?.forEach { item ->
            ports.add(lookupTraefikPort(item.jsonPrimitive.content))

            ingressRouteJSON.jsonObject["spec"]?.jsonObject["routes"]?.jsonArray?.forEach { routeJson ->
                when (routeJson.jsonObject["kind"]?.jsonPrimitive?.content?.lowercase()) {
                    "rule" -> routeJson.jsonObject["match"]?.jsonPrimitive?.content?.let {
                        ips.forEach { ip ->
                            ports.forEach { port ->
                                ingressRoutesMap.put(it, IPAndPort(ip = ip, port = port))
                            }
                        }
                    }
                    else -> config.prettyLogger.printlnWarning(
                        title = "No Traefik match `Rule` found",
                        message = "${routeJson.jsonObject["kind"]?.jsonPrimitive?.content}"
                    )
                }
            }
        }
    }

    private fun handleNode(resource: HasMetadata) {
        val node = config.importExportUtils.unmarshal<Node>(resource)

        node.status.addresses.forEach { address ->
            nodeIPAndPorts.add(
                IPAndPort(
                    name = resource.metadata.name,
                    ip = address.address
                )
            )
        }
    }

    private fun handleService(resource: HasMetadata) {
        val service = config.importExportUtils.unmarshal<Service>(resource)

        service.spec.clusterIPs.forEach { clusterIP ->
            serviceDNSAndPorts.add(
                IPAndPort(
                    namespace = resource.metadata.namespace,
                    name = resource.metadata.name,
                    dns = "${resource.metadata.name}.${resource.metadata.namespace}.svc.cluster.local",
                    ip = clusterIP
                )
            )

            service.spec.ports.forEach { portSpec ->
                serviceDNSAndPorts.add(
                    IPAndPort(
                        namespace = resource.metadata.namespace,
                        name = resource.metadata.name,
                        dns = "${resource.metadata.name}.${resource.metadata.namespace}.svc.cluster.local",
                        ip = clusterIP,
                        port = portSpec.port
                    )
                )
            }
        }
    }

    private fun handlePod(resource: HasMetadata) {
        val pod = config.importExportUtils.unmarshal<Pod>(resource)

        pod.status.podIPs.forEach { podIp ->
            var foundPort = false
            pod.spec.containers.forEach { container ->
                container.ports.forEach { port ->
                    foundPort = true
                    podIPAndPorts.add(
                        IPAndPort(
                            namespace = resource.metadata.namespace,
                            name = resource.metadata.name,
                            ip = podIp.ip,
                            port = port.hostPort
                        )
                    )
                }
            }
            if (!foundPort) {
                podIPAndPorts.add(
                    IPAndPort(
                        namespace = resource.metadata.namespace,
                        name = resource.metadata.name,
                        ip = podIp.ip
                    )
                )
            }
        }
    }
}
