package com.nickcoblentz.kubepentest.commands

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.data.DataSerializer
import com.nickcoblentz.kubepentest.models.KubePentestContext
import com.nickcoblentz.kubepentest.utils.HelmRelease
import com.nickcoblentz.kubepentest.utils.decodeHelmSecretData
import com.nickcoblentz.kubepentest.utils.parseHelmReleaseData
import io.fabric8.kubernetes.api.model.APIGroupList
import io.fabric8.kubernetes.api.model.APIResourceList
import io.fabric8.kubernetes.api.model.GenericKubernetesResource
import io.fabric8.kubernetes.api.model.Secret
import io.fabric8.kubernetes.client.dsl.base.ResourceDefinitionContext
import java.io.File
import java.io.FileWriter
import java.nio.file.Files
import kotlin.io.path.absolutePathString

/**
 * Command to dump all resources in the Kubernetes cluster.
 */
class DumpCluster : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = "${(TextColors.green)("(online)")} Dumps all resources in the cluster ${(TextColors.red)("(This command must be run first)")}"

    private val config by requireObject<KubePentestContext>()

    init {
        this.installMordantMarkdown()
    }

    /**
     * Generates a CSV file with resource counts by namespace and resource type
     */
    private fun generateResourceSummaryCSV(resourceCountsByNamespaceAndKind: Map<String, Map<String, Int>>, filePath: java.nio.file.Path) {
        FileWriter(File(filePath.toString())).use { writer ->
            // Get all namespaces and resource kinds
            val namespaces = resourceCountsByNamespaceAndKind.keys.sorted()
            val resourceKinds = resourceCountsByNamespaceAndKind.values.flatMap { it.keys }.distinct().sorted()

            // Write header row with namespaces
            writer.append("Resource Type")
            namespaces.forEach { namespace ->
                writer.append(",").append(namespace)
            }
            writer.append("\n")

            // Write data rows
            resourceKinds.forEach { kind ->
                writer.append(kind)
                namespaces.forEach { namespace ->
                    val count = resourceCountsByNamespaceAndKind[namespace]?.get(kind) ?: 0
                    writer.append(",").append(count.toString())
                }
                writer.append("\n")
            }
        }
    }

    /**
     * Generates a Markdown file with resource counts by namespace and resource type
     */
    private fun generateResourceSummaryMarkdown(resourceCountsByNamespaceAndKind: Map<String, Map<String, Int>>, filePath: java.nio.file.Path) {
        FileWriter(File(filePath.toString())).use { writer ->
            // Get all namespaces and resource kinds
            val namespaces = resourceCountsByNamespaceAndKind.keys.sorted()
            val resourceKinds = resourceCountsByNamespaceAndKind.values.flatMap { it.keys }.distinct().sorted()

            // Write title
            writer.append("# Kubernetes Resource Summary\n\n")

            // Write table header
            writer.append("| Resource Type |")
            namespaces.forEach { namespace ->
                writer.append(" ").append(namespace).append(" |")
            }
            writer.append("\n")

            // Write separator row
            writer.append("|---------------|")
            namespaces.forEach { _ ->
                writer.append("------------|")
            }
            writer.append("\n")

            // Write data rows
            resourceKinds.forEach { kind ->
                writer.append("| ").append(kind).append(" |")
                namespaces.forEach { namespace ->
                    val count = resourceCountsByNamespaceAndKind[namespace]?.get(kind) ?: 0
                    writer.append(" ").append(count.toString()).append(" |")
                }
                writer.append("\n")
            }
        }
    }

    override fun run() {
        config.prettyLogger.printlnMarkdown("## Dumping all resources from cluster")

        val helmReleases = mutableListOf<HelmRelease>()

        // Get all resources from the API server
        val allResources = mutableListOf<GenericKubernetesResource>()
        val resourcesByNamespace = mutableMapOf<String, MutableList<GenericKubernetesResource>>()
        val resourcesByKind = mutableMapOf<String, MutableList<GenericKubernetesResource>>()

        // Data structure to hold resource counts by namespace and kind
        val resourceCountsByNamespaceAndKind = mutableMapOf<String, MutableMap<String, Int>>()

        // 1. Get all API Groups
        val apiGroupList: APIGroupList = config.k8s.apiGroups
        val coreV1ResourceList: APIResourceList = config.k8s.getApiResources("v1")

        // Process core v1 resources
        coreV1ResourceList.resources.forEach { apiResource ->
            // Filter out subresources and non-listable resources
            if (apiResource.verbs.contains("list")
                && !apiResource.name.contains("/")
                && !apiResource.name.endsWith("/status")
            ) {
                try {
                    val resourceDefinitionContext = ResourceDefinitionContext.Builder()
                        .withGroup("") // Core group has an empty group name
                        .withVersion("v1")
                        .withPlural(apiResource.name)
                        .withKind(apiResource.kind)
                        .withNamespaced(apiResource.namespaced ?: false)
                        .build()

                    val genericOperation = config.k8s.genericKubernetesResources(resourceDefinitionContext)

                    val resources: List<GenericKubernetesResource> = if (apiResource.namespaced == true) {
                        genericOperation.inAnyNamespace().list().items
                    } else {
                        genericOperation.list().items
                    }

                    resources.forEach { res ->
                        allResources.add(res)

                        // Group by namespace
                        val namespace = res.metadata.namespace ?: "cluster-wide"
                        if (!resourcesByNamespace.containsKey(namespace)) {
                            resourcesByNamespace[namespace] = mutableListOf()
                        }
                        resourcesByNamespace[namespace]!!.add(res)

                        // Group by kind
                        val kind = res.kind
                        if (!resourcesByKind.containsKey(kind)) {
                            resourcesByKind[kind] = mutableListOf()
                        }
                        resourcesByKind[kind]!!.add(res)

                        // Count resources by namespace and kind
                        if (!resourceCountsByNamespaceAndKind.containsKey(namespace)) {
                            resourceCountsByNamespaceAndKind[namespace] = mutableMapOf()
                        }
                        val kindCount = resourceCountsByNamespaceAndKind[namespace]!!.getOrDefault(kind, 0)
                        resourceCountsByNamespaceAndKind[namespace]!![kind] = kindCount + 1
                    }

                    config.prettyLogger.printlnSuccess(message = "Found ${resources.size} ${apiResource.name}")
                } catch (e: Exception) {
                    config.prettyLogger.printlnError(message = "Error processing ${apiResource.name}: ${e.message}")
                    if (config.verbose) {
                        e.printStackTrace()
                    }
                }
            }
        }

        // Process API groups
        apiGroupList.groups.forEach { apiGroup ->
            apiGroup.versions.forEach { groupVersion ->
                try {
                    // Get API Resources for each GroupVersion
                    val apiResourceList: APIResourceList = config.k8s.getApiResources(groupVersion.groupVersion)

                    apiResourceList.resources.forEach { apiResource ->
                        // Exclude subresources and "status" which are not listable
                        if (apiResource.verbs.contains("list")
                            && !apiResource.name.contains("/")
                            && !apiResource.name.endsWith("/status")
                        ) {
                            try {
                                val resourceDefinitionContext = ResourceDefinitionContext.Builder()
                                    .withGroup(apiGroup.name)
                                    .withVersion(groupVersion.version)
                                    .withPlural(apiResource.name)
                                    .withKind(apiResource.kind)
                                    .withNamespaced(apiResource.namespaced ?: false)
                                    .build()

                                val genericOperation = config.k8s.genericKubernetesResources(resourceDefinitionContext)

                                val resources: List<GenericKubernetesResource> = if (apiResource.namespaced == true) {
                                    // If namespaced, list across all namespaces
                                    genericOperation.inAnyNamespace().list().items
                                } else {
                                    // If cluster-scoped
                                    genericOperation.list().items
                                }

                                resources.forEach { res ->
                                    allResources.add(res)

                                    // Group by namespace
                                    val namespace = res.metadata.namespace ?: "cluster-wide"
                                    if (!resourcesByNamespace.containsKey(namespace)) {
                                        resourcesByNamespace[namespace] = mutableListOf()
                                    }
                                    resourcesByNamespace[namespace]!!.add(res)

                                    // Group by kind
                                    val kind = res.kind
                                    if (!resourcesByKind.containsKey(kind)) {
                                        resourcesByKind[kind] = mutableListOf()
                                    }
                                    resourcesByKind[kind]!!.add(res)

                                    // Count resources by namespace and kind
                                    if (!resourceCountsByNamespaceAndKind.containsKey(namespace)) {
                                        resourceCountsByNamespaceAndKind[namespace] = mutableMapOf()
                                    }
                                    val kindCount = resourceCountsByNamespaceAndKind[namespace]!!.getOrDefault(kind, 0)
                                    resourceCountsByNamespaceAndKind[namespace]!![kind] = kindCount + 1
                                }

                                config.prettyLogger.printlnSuccess(message = "Found ${resources.size} ${apiResource.name}")
                            } catch (e: Exception) {
                                config.prettyLogger.printlnError(message = "Error processing ${apiResource.name}: ${e.message}")
                                if (config.verbose) {
                                    e.printStackTrace()
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    config.prettyLogger.printlnError(message = "Error processing ${groupVersion.groupVersion}: ${e.message}")
                    if (config.verbose) {
                        e.printStackTrace()
                    }
                }
            }
        }

        // Write resources by namespace
        resourcesByNamespace.forEach { (namespace, resources) ->
            var namespacePath = config.byNamespacedDataDirectoryPath("$namespace.json")
            config.importExportUtils.serializeToJsonFile(namespacePath.toString(), resources)
            config.prettyLogger.printlnSuccess(message = "Wrote ${resources.size} resources for namespace $namespace to ${namespacePath.absolutePathString()}")

            namespacePath = config.byNamespacedDataDirectoryPath("$namespace.yaml")
            config.importExportUtils.serializeToYamlFile(namespacePath.toString(), resources)
            config.prettyLogger.printlnSuccess(message = "Wrote ${resources.size} resources for namespace $namespace to ${namespacePath.absolutePathString()}")
        }

        // Write resources by kind
        resourcesByKind.forEach { (resourceKey, resources) ->
            var resourcePath = config.byResourceDataDirectoryPath("$resourceKey.json")
            config.importExportUtils.serializeToJsonFile(resourcePath.toString(), resources)
            config.prettyLogger.printlnSuccess(message = "Wrote ${resources.size} resources of kind $resourceKey to ${resourcePath.absolutePathString()}")

            resourcePath = config.byResourceDataDirectoryPath("$resourceKey.yaml")
            config.importExportUtils.serializeToYamlFile(resourcePath.toString(), resources)
            config.prettyLogger.printlnSuccess(message = "Wrote ${resources.size} resources of kind $resourceKey to ${resourcePath.absolutePathString()}")
        }

        // Write all resources
        config.importExportUtils.serializeToJsonFile(config.allJSONFilePath().toString(), allResources)
        config.prettyLogger.printlnSuccess(message = "Wrote ${allResources.size} resources to ${config.allJSONFilePath().absolutePathString()}")

        config.importExportUtils.serializeToYamlFile(config.allYAMLFilePath().toString(), allResources)
        config.prettyLogger.printlnSuccess(message = "Wrote ${allResources.size} resources to ${config.allYAMLFilePath().absolutePathString()}")

        // Process Helm secrets
        val secrets = resourcesByKind["Secret"]
        if (secrets != null) {
            secrets.forEach { resource ->
                try {
                    val secret = config.importExportUtils.unmarshal<Secret>(resource)
                    if (secret.type == "helm.sh/release.v1") {
                        val releaseData = decodeHelmSecretData(secret)
                        if (releaseData != null) {
                            val helmRelease = parseHelmReleaseData(releaseData)
                            if (helmRelease != null) {
                                helmReleases.add(helmRelease)
                            }
                        }
                    }
                } catch (e: Exception) {
                    config.prettyLogger.printlnError(message = "Error processing Helm secret: ${e.message}")
                    if (config.verbose) {
                        e.printStackTrace()
                    }
                }
            }
        }

        // Write Helm releases
//        var helmOutput = ""
//        helmReleases.forEach { release ->
//            helmOutput += "Name: ${release.name}, Chart: ${release.chartName}, Version: ${release.version}, AppVersion: ${release.appVersion}\n"
//        }
//
//        val helmPath = config.helmDirectoryPath("helmList.txt")
        val helmmdfilepath = config.helmDirectoryPath("helmList.md")
        Files.writeString(helmmdfilepath, DataSerializer.toMarkdownTable(helmReleases))

        val helmcsvpath = config.helmDirectoryPath("helmList.csv")
        Files.writeString(helmcsvpath, DataSerializer.toCsv(helmReleases))
        config.prettyLogger.printlnSuccess(message = "Wrote Helm File at: ${helmmdfilepath.absolutePathString()}")
        config.prettyLogger.printlnSuccess(message = "Wrote Helm File at: ${helmcsvpath.absolutePathString()}")

        // Generate resource summary CSV and Markdown files
        val csvPath = config.allDataDirectoryPath("resource-summary.csv")
        generateResourceSummaryCSV(resourceCountsByNamespaceAndKind, csvPath)
        config.prettyLogger.printlnSuccess(message = "Wrote Resource Summary CSV at: ${csvPath.absolutePathString()}")

        val markdownPath = config.allDataDirectoryPath("resource-summary.md")
        generateResourceSummaryMarkdown(resourceCountsByNamespaceAndKind, markdownPath)
        config.prettyLogger.printlnSuccess(message = "Wrote Resource Summary Markdown at: ${markdownPath.absolutePathString()}")

        config.prettyLogger.printlnInfo(title="Follow Up Command", message = "gitleaks dir ${config.allYAMLFilePath().absolutePathString()} -f csv -r gitleaks-all-yaml.csv")
        config.prettyLogger.printlnInfo(title="Follow Up Command", message = "gitleaks dir ${config.helmDirectoryPath().absolutePathString()} -f csv -r gitleaks-helm-dir.csv")
    }
}
