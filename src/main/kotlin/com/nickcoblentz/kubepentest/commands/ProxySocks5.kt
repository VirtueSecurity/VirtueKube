package com.nickcoblentz.kubepentest.commands

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.kubepentest.models.KubePentestContext
import io.fabric8.kubernetes.api.model.ContainerPort
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.client.Watcher
import io.fabric8.kubernetes.client.WatcherException
import io.fabric8.kubernetes.client.dsl.ExecWatch
import java.nio.file.Files
import java.util.Scanner
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference
import kotlin.io.path.Path
import kotlin.io.path.absolutePathString
import kotlin.io.path.exists

/**
 * Command to deploy a SOCKS5 proxy pod and set up port forwarding.
 * This command deploys a pod using the pod-template.yaml file as its base,
 * but replaces the image with serjs/go-socks5-proxy and opens TCP port 1080.
 * It detects if the pod is already deployed and prevents duplicate deployments.
 * Once deployed, it sets up port forwarding and waits for the user to type "quit"
 * before cleaning up.
 */
class ProxySocks5 : CliktCommand(name = "proxy-socks5") {
    override fun help(context: com.github.ajalt.clikt.core.Context) = 
        "${(TextColors.green)("(online)")} Deploy a SOCKS5 proxy pod and set up port forwarding on port 1080"

    private val namespaceOption by option("-n", "--namespace", help = "Namespace to deploy to").required()
    private val podTemplateOption by option("-p", "--pod-template", help = "Pod template file").default("testCases/pod-template.yaml")
    private val proxyLabelOption by option("-l", "--label", help = "Label to identify the proxy pod").default("app=socks5-proxy")
    
    private val config by requireObject<KubePentestContext>()
    private val proxyPodName = "socks5-proxy"
    private val proxyImage = "serjs/go-socks5-proxy"
    private val proxyPort = 1080
    
    private var portForwardProcess: Process? = null
    private var execWatch: ExecWatch? = null

    init {
        this.installMordantMarkdown()
    }

    override fun run() {
        // Check if proxy pod already exists
        if (checkProxyPodExists()) {
            config.prettyLogger.printlnError(
                title = "Error", 
                message = "SOCKS5 proxy pod already exists. Please delete it first or use a different label."
            )
            return
        }

        // Deploy the proxy pod
        deployProxyPod()
    }

    /**
     * Check if a proxy pod with the specified label already exists
     */
    private fun checkProxyPodExists(): Boolean {
        val labelKey = proxyLabelOption.split("=")[0]
        val labelValue = proxyLabelOption.split("=")[1]
        
        val existingPods = config.k8s.pods()
            .inNamespace(namespaceOption)
            .withLabel(labelKey, labelValue)
            .list()
            .items
            
        return existingPods.isNotEmpty()
    }

    /**
     * Deploy the proxy pod using the pod template
     */
    private fun deployProxyPod() {
        val podPath = Path(podTemplateOption)
        if (!podPath.exists()) {
            config.prettyLogger.printlnError(
                title = "Error", 
                message = "Pod template file not found: ${podPath.absolutePathString()}"
            )
            return
        }

        config.prettyLogger.printlnInfo(
            title = "Pod Template", 
            message = "Loading ${podPath.absolutePathString()}"
        )
        val podTemplateYaml = Files.readString(podPath)

        try {
            // Load and modify the pod template
            val pod = config.k8s.pods().load(podTemplateYaml.byteInputStream()).item()
            
            // Modify the pod for SOCKS5 proxy
            modifyPodForProxy(pod)

            // Deploy the pod
            config.prettyLogger.printlnInfo(
                title = "Pod", 
                message = "Deploying SOCKS5 proxy pod $proxyPodName to namespace $namespaceOption"
            )
            val createdPod = config.k8s.pods().inNamespace(namespaceOption).resource(pod).create()

            // Wait for the pod to be ready
            waitForPodReady(createdPod)

            // Set up port forwarding
            setupPortForwarding(createdPod)

            // Wait for user to type "quit"
            waitForQuitCommand()

        } catch (e: Exception) {
            config.prettyLogger.printlnError(
                title = "Error", 
                message = "Failed to deploy proxy pod: ${e.message}"
            )
            e.printStackTrace()
        } finally {
            // Clean up resources
            cleanUp()
        }
    }

    /**
     * Modify the pod template for the SOCKS5 proxy
     */
    private fun modifyPodForProxy(pod: Pod) {
        // Set pod name and label
        pod.metadata.name = proxyPodName
        val labelKey = proxyLabelOption.split("=")[0]
        val labelValue = proxyLabelOption.split("=")[1]
        pod.metadata.labels[labelKey] = labelValue

        // Modify container settings
        val container = pod.spec.containers[0]
        container.image = proxyImage
        
        // Remove command to use the default entrypoint
        container.command = null
        
        // Add port 1080
        val containerPort = ContainerPort()
        containerPort.containerPort = proxyPort
        containerPort.protocol = "TCP"
        containerPort.name = "socks5"
        
        if (container.ports == null) {
            container.ports = mutableListOf()
        }
        container.ports.add(containerPort)
        
        // Set restart policy to Always to keep the proxy running
        pod.spec.restartPolicy = "Always"
    }

    /**
     * Wait for the pod to be ready
     */
    private fun waitForPodReady(pod: Pod) {
        val podName = pod.metadata.name
        val podReady = AtomicBoolean(false)
        val podFailed = AtomicBoolean(false)
        val podFailureReason = AtomicReference<String?>(null)

        val podWatcher = object : Watcher<Pod> {
            override fun eventReceived(action: Watcher.Action, resource: Pod) {
                if (resource.metadata.name == podName) {
                    val phase = resource.status?.phase
                    
                    config.prettyLogger.printlnInfo(
                        title = "Pod '$podName'",
                        message = "Status: Phase=$phase"
                    )

                    if (phase == "Running") {
                        // Check if all containers are ready
                        val allContainersReady = resource.status?.containerStatuses?.all { it.ready } ?: false
                        if (allContainersReady) {
                            config.prettyLogger.printlnInfo(message = "Pod '$podName' is ready.")
                            podReady.set(true)
                        }
                    } else if (phase == "Failed") {
                        val reason = resource.status?.reason ?: "Unknown reason"
                        config.prettyLogger.printlnInfo(
                            title = "Pod '$podName' failed", 
                            message = "Reason: $reason"
                        )
                        podFailureReason.set(reason)
                        podFailed.set(true)
                    }
                }
            }

            override fun onClose(cause: WatcherException?) {
                if (cause != null) {
                    config.prettyLogger.printlnInfo(
                        message = "Pod Watcher closed with exception: ${cause.message}"
                    )
                    podFailed.set(true)
                    podFailureReason.set("Watcher closed unexpectedly: ${cause.message}")
                }
            }
        }

        // Start a thread to monitor the pod
        val monitorThread = Thread.startVirtualThread {
            config.k8s.pods().inNamespace(namespaceOption).withName(podName).watch(podWatcher).use { watcher ->
                val startTime = System.currentTimeMillis()
                val timeoutMillis = 180 * 1000 // 3 minutes timeout
                
                while (!podReady.get() && !podFailed.get()) {
                    if (System.currentTimeMillis() - startTime > timeoutMillis) {
                        config.prettyLogger.printlnWarning(
                            title = "Timeout", 
                            message = "Pod '$podName' did not become ready within 3 minutes"
                        )
                        podFailed.set(true)
                        break
                    }
                    Thread.sleep(1000)
                }
            }
        }

        // Wait for the monitor thread to complete
        monitorThread.join()

        if (podFailed.get()) {
            throw RuntimeException("Pod failed to become ready: ${podFailureReason.get()}")
        }
    }

    /**
     * Set up port forwarding from local port 1080 to pod port 1080
     */
    private fun setupPortForwarding(pod: Pod) {
        val podName = pod.metadata.name
        
        config.prettyLogger.printlnInfo(
            title = "Port Forwarding", 
            message = "Setting up port forwarding from localhost:$proxyPort to $podName:$proxyPort"
        )
        
        try {
            // Use kubectl port-forward command
            val processBuilder = ProcessBuilder(
                "kubectl", 
                "--namespace", namespaceOption, 
                "port-forward", 
                podName, 
                "$proxyPort:$proxyPort"
            )
            
            processBuilder.redirectErrorStream(true)
            portForwardProcess = processBuilder.start()
            
            // Start a thread to read the process output
            Thread.startVirtualThread {
                val scanner = Scanner(portForwardProcess!!.inputStream)
                while (scanner.hasNextLine()) {
                    val line = scanner.nextLine()
                    config.prettyLogger.printlnInfo(
                        title = "Port Forward", 
                        message = line
                    )
                }
            }
            
            // Give port forwarding a moment to establish
            Thread.sleep(2000)
            
            config.prettyLogger.printlnInfo(
                title = "SOCKS5 Proxy", 
                message = "Proxy is now available at localhost:$proxyPort"
            )
            config.prettyLogger.printlnInfo(
                title = "Usage", 
                message = "Configure your application to use SOCKS5 proxy at localhost:$proxyPort"
            )
            config.prettyLogger.printlnInfo(
                title = "Burp",
                message = "In Burp Suite, go to Settings -> Network -> Connections SOCKS Proxy. Add 127.0.0.1 for the host. Add $proxyPort for the port. Checkmark \"Use SOCKS Proxy\""
            )
            config.prettyLogger.printlnInfo(
                title = "gowitness command",
                message = "$ gowitness scan --chrome-proxy socks5://127.0.0.1:1080 file -f hosts.txt --write-screenshots --write-db -D\n$ gowitness report server"
            )

            config.prettyLogger.printlnInfo(
                title = "How to stop the pod",
                message = "Type 'quit' to stop the proxy and clean up resources"
            )
            
        } catch (e: Exception) {
            config.prettyLogger.printlnError(
                title = "Error", 
                message = "Failed to set up port forwarding: ${e.message}"
            )
            throw e
        }
    }

    /**
     * Wait for the user to type "quit"
     */
    private fun waitForQuitCommand() {
        val scanner = Scanner(System.`in`)
        
        while (true) {
            val input = scanner.nextLine().trim()
            if (input.equals("quit", ignoreCase = true)) {
                config.prettyLogger.printlnInfo(
                    title = "Shutdown", 
                    message = "Stopping proxy and cleaning up resources..."
                )
                break
            } else {
                config.prettyLogger.printlnInfo(
                    message = "Type 'quit' to stop the proxy and clean up resources"
                )
            }
        }
    }

    /**
     * Clean up resources (port forwarding and pod)
     */
    private fun cleanUp() {
        // Stop port forwarding
        portForwardProcess?.let {
            try {
                it.destroy()
                config.prettyLogger.printlnInfo(
                    title = "Cleanup", 
                    message = "Port forwarding stopped"
                )
            } catch (e: Exception) {
                config.prettyLogger.printlnWarning(
                    title = "Warning", 
                    message = "Failed to stop port forwarding: ${e.message}"
                )
            }
        }
        
        // Close exec watch if open
        execWatch?.let {
            try {
                it.close()
            } catch (e: Exception) {
                // Ignore
            }
        }
        
        // Delete the pod
        try {
            val labelKey = proxyLabelOption.split("=")[0]
            val labelValue = proxyLabelOption.split("=")[1]
            
            val pods = config.k8s.pods()
                .inNamespace(namespaceOption)
                .withLabel(labelKey, labelValue)
                .list()
                .items
                
            if (pods.isNotEmpty()) {
                for (pod in pods) {
                    config.k8s.pods()
                        .inNamespace(namespaceOption)
                        .withName(pod.metadata.name)
                        .delete()
                        
                    config.prettyLogger.printlnInfo(
                        title = "Cleanup", 
                        message = "Deleted pod ${pod.metadata.name}"
                    )
                }
            }
        } catch (e: Exception) {
            config.prettyLogger.printlnWarning(
                title = "Warning", 
                message = "Failed to delete proxy pod: ${e.message}"
            )
        }
    }
}