package com.nickcoblentz.kubepentest.commands

import com.fasterxml.jackson.annotation.JsonProperty
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.data.CsvColumnMapping
import com.nickcoblentz.data.DataSerializer
import com.nickcoblentz.kubepentest.models.KubePentestContext
import io.fabric8.kubernetes.api.model.Container
import io.fabric8.kubernetes.api.model.HasMetadata
import io.fabric8.kubernetes.api.model.PersistentVolumeClaim
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.Secret
import io.fabric8.kubernetes.api.model.Service
import io.fabric8.kubernetes.api.model.Volume
import io.fabric8.kubernetes.api.model.apps.Deployment
import io.fabric8.kubernetes.api.model.extensions.Ingress
import io.fabric8.kubernetes.api.model.rbac.ClusterRole
import io.fabric8.kubernetes.api.model.rbac.ClusterRoleBinding
import io.fabric8.kubernetes.api.model.rbac.Role
import io.fabric8.kubernetes.api.model.rbac.RoleBinding
import io.fabric8.kubernetes.client.utils.Serialization
import java.io.File
import java.io.FileWriter
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.absolutePathString
import kotlin.time.Clock
import kotlin.time.ExperimentalTime

/**
 * Command to analyze Kubernetes resources for security concerns.
 */
class SecurityAnalysis : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = 
        "${(TextColors.gray)("(offline)")} Analyzes Kubernetes resources for security concerns"

    private val config by requireObject<KubePentestContext>()

    // Data class to hold security findings
    data class SecurityFinding @OptIn(ExperimentalTime::class) constructor(
        @CsvColumnMapping(name = "Date", order = 8)
        @JsonProperty("date")
        val date : String = Clock.System.now().toString(),

        @CsvColumnMapping(name = "Namespace", order = 2)
        @JsonProperty("namespace")
        val namespace: String,

        @CsvColumnMapping(name = "Pod Name", order = 5)
        @JsonProperty("podName")
        val podName: String,

        @CsvColumnMapping(name = "Container Name", order = 6)
        @JsonProperty("containerName")
        val containerName: String,

        @CsvColumnMapping(name = "Issue Title", order = 1)
        @JsonProperty("issue")
        val issue: String,

        @CsvColumnMapping(name = "Details", order = 7)
        @JsonProperty("details")
        val details: String,

        @CsvColumnMapping(name = "Resource Type", order = 3)
        @JsonProperty("resourceType")
        val resourceType: String = "Pod",

        @CsvColumnMapping(name = "Resource Name", order = 4)
        @JsonProperty("resourceName")
        val resourceName: String = podName,

        @CsvColumnMapping(name = "Kubectl Command", order = 9)
        @JsonProperty("kubectlCommand")
        val kubectlCommand: String = generateKubectlCommand(namespace, resourceType, resourceName)
    )

    companion object {
        /**
         * Generates a kubectl command to get the YAML of a resource
         */
        fun generateKubectlCommand(namespace: String, resourceType: String, resourceName: String): String {
            val namespaceFlag = if (namespace != "cluster-wide") "-n $namespace" else ""
            val resourceTypeArg = resourceType.lowercase()
            return "kubectl get $resourceTypeArg $namespaceFlag -o yaml $resourceName"
        }
    }

    override fun run() {
        config.prettyLogger.printlnInfo(title = "Analyzing Kubernetes resources for security concerns")

        // Check if all.json exists
        val allJsonPath = config.allJSONFilePath()
        if (!Files.exists(allJsonPath)) {
            config.prettyLogger.printlnError(message = "File ${allJsonPath.absolutePathString()} not found. Run 'dump-cluster' command first.")
            return
        }

        // Parse all.json file
        val resources = config.importExportUtils.deserializeFromFile(allJsonPath.toString())
        config.prettyLogger.printlnInfo(message = "Loaded ${resources.size} resources from ${allJsonPath.absolutePathString()}")

        // Analyze resources for security concerns
        val findings = mutableListOf<SecurityFinding>()

        // Filter for Pod resources
        val pods = resources.filter { it.kind == "Pod" }
        config.prettyLogger.printlnInfo(message = "Found ${pods.size} Pod resources")

        // Filter for other resource types
        val secrets = resources.filter { it.kind == "Secret" }
        config.prettyLogger.printlnInfo(message = "Found ${secrets.size} Secret resources")

        val services = resources.filter { it.kind == "Service" }
        config.prettyLogger.printlnInfo(message = "Found ${services.size} Service resources")

        val deployments = resources.filter { it.kind == "Deployment" }
        config.prettyLogger.printlnInfo(message = "Found ${deployments.size} Deployment resources")

        val roles = resources.filter { it.kind == "Role" }
        config.prettyLogger.printlnInfo(message = "Found ${roles.size} Role resources")

        val roleBindings = resources.filter { it.kind == "RoleBinding" }
        config.prettyLogger.printlnInfo(message = "Found ${roleBindings.size} RoleBinding resources")

        val clusterRoles = resources.filter { it.kind == "ClusterRole" }
        config.prettyLogger.printlnInfo(message = "Found ${clusterRoles.size} ClusterRole resources")

        val clusterRoleBindings = resources.filter { it.kind == "ClusterRoleBinding" }
        config.prettyLogger.printlnInfo(message = "Found ${clusterRoleBindings.size} ClusterRoleBinding resources")

        val pvcs = resources.filter { it.kind == "PersistentVolumeClaim" }
        config.prettyLogger.printlnInfo(message = "Found ${pvcs.size} PersistentVolumeClaim resources")

        val ingresses = resources.filter { it.kind == "Ingress" }
        config.prettyLogger.printlnInfo(message = "Found ${ingresses.size} Ingress resources")

        val kyvernoPolicies = resources.filter { it.kind == "ClusterPolicy" || it.kind == "Policy" }
        config.prettyLogger.printlnInfo(message = "Found ${kyvernoPolicies.size} Kyverno policy resources")

        // Filter for External Secrets Operator resources
        val clusterSecretStores = resources.filter { it.kind == "ClusterSecretStore" }
        config.prettyLogger.printlnInfo(message = "Found ${clusterSecretStores.size} ClusterSecretStore resources")

        val secretStores = resources.filter { it.kind == "SecretStore" }
        config.prettyLogger.printlnInfo(message = "Found ${secretStores.size} SecretStore resources")

        val externalSecrets = resources.filter { it.kind == "ExternalSecret" }
        config.prettyLogger.printlnInfo(message = "Found ${externalSecrets.size} ExternalSecret resources")

        // Analyze RBAC resources
        analyzeRBACResources(roles, roleBindings, clusterRoles, clusterRoleBindings, findings)

        // Analyze Secret resources
        analyzeSecrets(secrets, findings)

        // Analyze Service resources
        analyzeServices(services, findings)

        // Analyze Deployment resources
        analyzeDeployments(deployments, findings)

        // Analyze PersistentVolumeClaim resources
        analyzePVCs(pvcs, findings)

        // Check for unmounted PVCs
        checkUnmountedPVCs(pvcs, pods, findings)

        // Analyze Ingress resources
        analyzeIngresses(ingresses, findings)

        // Analyze Kyverno policies
        analyzeKyvernoPolicies(kyvernoPolicies, findings)

        // Analyze External Secrets Operator resources
        analyzeExternalSecretsResources(clusterSecretStores, secretStores, externalSecrets, findings)

        pods.forEach { resource ->
            try {
                val pod = config.importExportUtils.unmarshal<Pod>(resource)
                val namespace = pod.metadata.namespace ?: "cluster-wide"
                val podName = pod.metadata.name

                // Check pod-level security concerns
                if (pod.spec.hostNetwork == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = podName,
                        containerName = "N/A",
                        issue = "Host Network",
                        details = "Pod uses host network namespace"
                    ))
                }

                if (pod.spec.hostPID == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = podName,
                        containerName = "N/A",
                        issue = "Host PID",
                        details = "Pod uses host PID namespace"
                    ))
                }

                if (pod.spec.hostIPC == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = podName,
                        containerName = "N/A",
                        issue = "Host IPC",
                        details = "Pod uses host IPC namespace"
                    ))
                }

                // Check for sysctls (Pod Security Standards - Baseline)
                pod.spec.securityContext?.sysctls?.forEach { sysctl ->
                    // List of allowed sysctls in Pod Security Standards Baseline
                    val allowedSysctls = listOf(
                        "kernel.shm_rmid_forced",
                        "net.ipv4.ip_local_port_range",
                        "net.ipv4.ip_unprivileged_port_start",
                        "net.ipv4.tcp_syncookies",
                        "net.ipv4.ping_group_range",
                        "net.ipv4.ip_local_reserved_ports",
                        "net.ipv4.tcp_keepalive_time",
                        "net.ipv4.tcp_fin_timeout",
                        "net.ipv4.tcp_keepalive_intvl",
                        "net.ipv4.tcp_keepalive_probes"
                    )

                    if (!allowedSysctls.contains(sysctl.name)) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = podName,
                            containerName = "N/A",
                            issue = "Unsafe Sysctl",
                            details = "Pod uses unsafe sysctl: ${sysctl.name}"
                        ))
                    }
                }

                // Check for AppArmor profile (Pod Security Standards - Baseline)
                pod.metadata.annotations?.forEach { (key, value) ->
                    if (key.startsWith("container.apparmor.security.beta.kubernetes.io/")) {
                        if (value == "unconfined") {
                            val containerName = key.removePrefix("container.apparmor.security.beta.kubernetes.io/")
                            findings.add(SecurityFinding(
                                namespace = namespace,
                                podName = podName,
                                containerName = containerName,
                                issue = "Unconfined AppArmor",
                                details = "Container '$containerName' uses 'unconfined' AppArmor profile"
                            ))
                        }
                    }
                }

                // Check for SELinux options (Pod Security Standards - Baseline)
                if (pod.spec.securityContext?.seLinuxOptions != null) {
                    val seLinuxOptions = pod.spec.securityContext.seLinuxOptions
                    if (seLinuxOptions.type == "unconfined") {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = podName,
                            containerName = "N/A",
                            issue = "Unconfined SELinux",
                            details = "Pod uses 'unconfined' SELinux type"
                        ))
                    }
                }

                // Check for Windows Host Process (Pod Security Standards - Baseline)
                if (pod.spec.securityContext?.windowsOptions?.hostProcess == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = podName,
                        containerName = "N/A",
                        issue = "Windows Host Process",
                        details = "Pod uses Windows HostProcess containers"
                    ))
                }

                // Check for image pull secrets
                if (pod.spec.imagePullSecrets.isNullOrEmpty()) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = podName,
                        containerName = "N/A",
                        issue = "Missing Image Pull Secrets",
                        details = "Pod does not specify image pull secrets, which may use public images or default credentials"
                    ))
                }

                // Check for sensitive volume mounts
                pod.spec.volumes?.forEach { volume ->
                    checkVolumeForSecurityConcerns(volume, namespace, podName, findings)
                }

                // Check container-level security concerns
                pod.spec.containers?.forEach { container ->
                    checkContainerForSecurityConcerns(container, namespace, podName, findings)
                }

                // Check init containers as well
                pod.spec.initContainers?.forEach { container ->
                    checkContainerForSecurityConcerns(container, namespace, podName, findings)
                }

            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing pod: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Output findings
        if (findings.isEmpty()) {
            config.prettyLogger.printlnSuccess(message = "No security concerns found")
        } else {
            config.prettyLogger.printlnWarning(message = "Found ${findings.size} security concerns")

            // Write findings to CSV
            val csvPath = config.securityDirectoryPath("security-findings-${System.currentTimeMillis()}.csv")
            writeFindings(findings, csvPath, FileFormat.CSV)
            config.prettyLogger.printlnSuccess(message = "Wrote security findings to ${csvPath.absolutePathString()}")

            // Write findings to Markdown
            val mdPath = config.securityDirectoryPath("security-findings-${System.currentTimeMillis()}.md")
            writeFindings(findings, mdPath, FileFormat.MARKDOWN)
            config.prettyLogger.printlnSuccess(message = "Wrote security findings to ${mdPath.absolutePathString()}")
        }
    }

    private fun checkContainerForSecurityConcerns(
        container: Container,
        namespace: String,
        podName: String,
        findings: MutableList<SecurityFinding>
    ) {
        val containerName = container.name

        // Check if running as root
        val securityContext = container.securityContext
        if (securityContext?.runAsNonRoot != true) {
            val runAsUser = securityContext?.runAsUser
            if (runAsUser == null || runAsUser == 0L) {
                findings.add(SecurityFinding(
                    namespace = namespace,
                    podName = podName,
                    containerName = containerName,
                    issue = "Running as Root",
                    details = "Container may run as root user (runAsNonRoot not set to true or runAsUser=0)"
                ))
            }
        }

        // Check for privileged containers
        if (securityContext?.privileged == true) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Privileged Container",
                details = "Container runs with privileged security context"
            ))
        }

        // Check for dangerous capabilities
        val dangerousCapabilities = listOf(
            "SYS_ADMIN", "NET_ADMIN", "ALL", "CAP_SYS_ADMIN", "CAP_NET_ADMIN", "CAP_ALL"
        )
        securityContext?.capabilities?.add?.forEach { capability ->
            if (dangerousCapabilities.contains(capability)) {
                findings.add(SecurityFinding(
                    namespace = namespace,
                    podName = podName,
                    containerName = containerName,
                    issue = "Dangerous Capability",
                    details = "Container has dangerous capability: $capability"
                ))
            }
        }

        // Check for allowPrivilegeEscalation
        if (securityContext?.allowPrivilegeEscalation == true) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Privilege Escalation",
                details = "Container allows privilege escalation"
            ))
        }

        // Check for seccomp profile (Pod Security Standards - Restricted)
        if (securityContext?.seccompProfile == null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Missing Seccomp Profile",
                details = "Container does not have a seccomp profile configured"
            ))
        } else if (securityContext.seccompProfile.type == "Unconfined") {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Unconfined Seccomp Profile",
                details = "Container uses 'Unconfined' seccomp profile which disables seccomp"
            ))
        }

        // Check for readOnlyRootFilesystem (Pod Security Standards - Restricted)
        if (securityContext?.readOnlyRootFilesystem != true) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Writable Root Filesystem",
                details = "Container does not have a read-only root filesystem"
            ))
        }

        // Check for dropping all capabilities (Pod Security Standards - Restricted)
        if (securityContext?.capabilities?.drop == null || !securityContext.capabilities.drop.contains("ALL")) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Not Dropping All Capabilities",
                details = "Container does not drop ALL capabilities before adding specific ones"
            ))
        }

        // Check for non-root group (Pod Security Standards - Restricted)
        if (securityContext?.runAsGroup == null || securityContext.runAsGroup == 0L) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = containerName,
                issue = "Running as Root Group",
                details = "Container may run with root group ID (runAsGroup not set or set to 0)"
            ))
        }
    }

    private fun checkVolumeForSecurityConcerns(
        volume: Volume,
        namespace: String,
        podName: String,
        findings: MutableList<SecurityFinding>
    ) {
        // Check for sensitive hostPath volumes
        val hostPath = volume.hostPath
        if (hostPath != null) {
            val path = hostPath.path
            val sensitivePaths = listOf(
                "/", "/etc", "/var", "/var/run/docker.sock", "/var/lib/kubelet", 
                "/var/lib/docker", "/run", "/dev"
            )

            sensitivePaths.forEach { sensitivePath ->
                if (path != null && (path == sensitivePath || path.startsWith("$sensitivePath/"))) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = podName,
                        containerName = "N/A",
                        issue = "Sensitive HostPath",
                        details = "Pod mounts sensitive host path: $path"
                    ))
                }
            }

            // Any hostPath is a violation of Pod Security Standards - Baseline
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "HostPath Volume",
                details = "Pod uses hostPath volume which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for restricted volume types (Pod Security Standards - Baseline)
        val volumeName = volume.name

        // Check for GCE Persistent Disk
        if (volume.gcePersistentDisk != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses gcePersistentDisk volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for AWS Elastic Block Store
        if (volume.awsElasticBlockStore != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses awsElasticBlockStore volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for GitRepo
        if (volume.gitRepo != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses gitRepo volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for NFS
        if (volume.nfs != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses nfs volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for ISCSI
        if (volume.iscsi != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses iscsi volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for Glusterfs
        if (volume.glusterfs != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses glusterfs volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for RBD (Rados Block Device)
        if (volume.rbd != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses rbd volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for FlexVolume
        if (volume.flexVolume != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses flexVolume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for Cinder
        if (volume.cinder != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses cinder volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for CephFS
        if (volume.cephfs != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses cephfs volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for Flocker
        if (volume.flocker != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses flocker volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for FC (Fibre Channel)
        if (volume.fc != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses fc volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for AzureFile
        if (volume.azureFile != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses azureFile volume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }

        // Check for VsphereVolume
        if (volume.vsphereVolume != null) {
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = podName,
                containerName = "N/A",
                issue = "Restricted Volume Type",
                details = "Pod uses vsphereVolume '$volumeName' which is not allowed in Pod Security Standards Baseline"
            ))
        }
    }

    enum class FileFormat {
        CSV, MARKDOWN
    }

    /**
     * Analyzes RBAC resources for security concerns
     */
    private fun analyzeRBACResources(
        roles: List<HasMetadata>,
        roleBindings: List<HasMetadata>,
        clusterRoles: List<HasMetadata>,
        clusterRoleBindings: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        // Check for overly permissive roles
        roles.forEach { resource ->
            try {
                val role = config.importExportUtils.unmarshal<Role>(resource)
                val namespace = role.metadata.namespace ?: "default"
                val roleName = role.metadata.name

                // Check for wildcard permissions
                role.rules?.forEach { rule ->
                    if (rule.apiGroups?.contains("*") == true || 
                        rule.resources?.contains("*") == true || 
                        rule.verbs?.contains("*") == true) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = "N/A",
                            containerName = "N/A",
                            issue = "Overly Permissive Role",
                            details = "Role '$roleName' has wildcard permissions: apiGroups=${rule.apiGroups}, resources=${rule.resources}, verbs=${rule.verbs}",
                            resourceType = "Role",
                            resourceName = roleName
                        ))
                    }
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing role: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Check for overly permissive cluster roles
        clusterRoles.forEach { resource ->
            try {
                val clusterRole = config.importExportUtils.unmarshal<ClusterRole>(resource)
                val roleName = clusterRole.metadata.name

                // Check for wildcard permissions
                clusterRole.rules?.forEach { rule ->
                    if (rule.apiGroups?.contains("*") == true || 
                        rule.resources?.contains("*") == true || 
                        rule.verbs?.contains("*") == true) {
                        findings.add(SecurityFinding(
                            namespace = "cluster-wide",
                            podName = "N/A",
                            containerName = "N/A",
                            issue = "Overly Permissive ClusterRole",
                            details = "ClusterRole '$roleName' has wildcard permissions: apiGroups=${rule.apiGroups}, resources=${rule.resources}, verbs=${rule.verbs}",
                            resourceType = "ClusterRole",
                            resourceName = roleName
                        ))
                    }
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing cluster role: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Check for service accounts bound to powerful roles
        roleBindings.forEach { resource ->
            try {
                val roleBinding = config.importExportUtils.unmarshal<RoleBinding>(resource)
                val namespace = roleBinding.metadata.namespace ?: "default"
                val bindingName = roleBinding.metadata.name
                val roleName = roleBinding.roleRef.name

                // Check if bound to a role with "admin" or "cluster-admin" in the name
                if (roleName.contains("admin", ignoreCase = true)) {
                    roleBinding.subjects?.forEach { subject ->
                        if (subject.kind == "ServiceAccount") {
                            findings.add(SecurityFinding(
                                namespace = namespace,
                                podName = "N/A",
                                containerName = "N/A",
                                issue = "ServiceAccount with Admin Role",
                                details = "ServiceAccount '${subject.name}' in namespace '${subject.namespace ?: namespace}' is bound to admin role '$roleName' via RoleBinding '$bindingName'",
                                resourceType = "RoleBinding",
                                resourceName = bindingName
                            ))
                        }
                    }
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing role binding: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Check for service accounts bound to powerful cluster roles
        clusterRoleBindings.forEach { resource ->
            try {
                val clusterRoleBinding = config.importExportUtils.unmarshal<ClusterRoleBinding>(resource)
                val bindingName = clusterRoleBinding.metadata.name
                val roleName = clusterRoleBinding.roleRef.name

                // Check if bound to a cluster role with "admin" or "cluster-admin" in the name
                if (roleName.contains("admin", ignoreCase = true)) {
                    clusterRoleBinding.subjects?.forEach { subject ->
                        if (subject.kind == "ServiceAccount") {
                            findings.add(SecurityFinding(
                                namespace = subject.namespace ?: "default",
                                podName = "N/A",
                                containerName = "N/A",
                                issue = "ServiceAccount with Admin ClusterRole",
                                details = "ServiceAccount '${subject.name}' in namespace '${subject.namespace ?: "default"}' is bound to admin cluster role '$roleName' via ClusterRoleBinding '$bindingName'",
                                resourceType = "ClusterRoleBinding",
                                resourceName = bindingName
                            ))
                        }
                    }
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing cluster role binding: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Analyzes Secret resources for security concerns
     */
    private fun analyzeSecrets(
        secrets: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        secrets.forEach { resource ->
            try {
                val secret = config.importExportUtils.unmarshal<Secret>(resource)
                val namespace = secret.metadata.namespace ?: "default"
                val secretName = secret.metadata.name

                // Check for default service account token secrets
                if (secretName.startsWith("default-token-")) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Default ServiceAccount Token",
                        details = "Default service account token secret '$secretName' found in namespace '$namespace'. Default service accounts should be configured with automountServiceAccountToken: false",
                        resourceType = "Secret",
                        resourceName = secretName
                    ))
                }

                // Check for secrets with potentially sensitive data
                val sensitiveKeys = listOf(
                    "password", "secret", "key", "token", "credential", "access", "auth", "private"
                )

                secret.data?.keys?.forEach { key ->
                    if (sensitiveKeys.any { sensitive -> key.contains(sensitive, ignoreCase = true) }) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = "N/A",
                            containerName = "N/A",
                            issue = "Potentially Sensitive Secret",
                            details = "Secret '$secretName' contains potentially sensitive key '$key'",
                            resourceType = "Secret",
                            resourceName = secretName
                        ))
                    }
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing secret: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Analyzes Service resources for security concerns
     */
    private fun analyzeServices(
        services: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        services.forEach { resource ->
            try {
                val service = config.importExportUtils.unmarshal<Service>(resource)
                val namespace = service.metadata.namespace ?: "default"
                val serviceName = service.metadata.name

                // Check for NodePort services
                if (service.spec.type == "NodePort") {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "NodePort Service",
                        details = "Service '$serviceName' uses NodePort type which exposes ports on all nodes",
                        resourceType = "Service",
                        resourceName = serviceName
                    ))
                }

                // Check for LoadBalancer services
                if (service.spec.type == "LoadBalancer") {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "LoadBalancer Service",
                        details = "Service '$serviceName' uses LoadBalancer type which may expose services externally",
                        resourceType = "Service",
                        resourceName = serviceName
                    ))
                }

                // Check for services with externalIPs (CVE-2020-8554)
                if (!service.spec.externalIPs.isNullOrEmpty()) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Service with ExternalIPs",
                        details = "Service '$serviceName' has externalIPs ${service.spec.externalIPs} which could be used for man-in-the-middle attacks (CVE-2020-8554)",
                        resourceType = "Service",
                        resourceName = serviceName
                    ))
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing service: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Analyzes Deployment resources for security concerns
     */
    private fun analyzeDeployments(
        deployments: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        deployments.forEach { resource ->
            try {
                val deployment = config.importExportUtils.unmarshal<Deployment>(resource)
                val namespace = deployment.metadata.namespace ?: "default"
                val deploymentName = deployment.metadata.name

                // Check for deployments without resource limits
                deployment.spec.template.spec.containers?.forEach { container ->
                    val containerName = container.name

                    // Check for missing resource limits
                    if (container.resources?.limits == null || container.resources.limits.isEmpty()) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = deploymentName,
                            containerName = containerName,
                            issue = "Missing Resource Limits",
                            details = "Container '$containerName' in deployment '$deploymentName' does not have resource limits set"
                        ))
                    }

                    // Check for containers running as root
                    val securityContext = container.securityContext
                    if (securityContext?.runAsNonRoot != true) {
                        val runAsUser = securityContext?.runAsUser
                        if (runAsUser == null || runAsUser == 0L) {
                            findings.add(SecurityFinding(
                                namespace = namespace,
                                podName = deploymentName,
                                containerName = containerName,
                                issue = "Running as Root",
                                details = "Container '$containerName' in deployment '$deploymentName' may run as root user (runAsNonRoot not set to true or runAsUser=0)"
                            ))
                        }
                    }

                    // Check for privileged containers
                    if (securityContext?.privileged == true) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = deploymentName,
                            containerName = containerName,
                            issue = "Privileged Container",
                            details = "Container '$containerName' in deployment '$deploymentName' runs with privileged security context"
                        ))
                    }

                    // Check for dangerous capabilities
                    val dangerousCapabilities = listOf(
                        "SYS_ADMIN", "NET_ADMIN", "ALL", "CAP_SYS_ADMIN", "CAP_NET_ADMIN", "CAP_ALL"
                    )
                    securityContext?.capabilities?.add?.forEach { capability ->
                        if (dangerousCapabilities.contains(capability)) {
                            findings.add(SecurityFinding(
                                namespace = namespace,
                                podName = deploymentName,
                                containerName = containerName,
                                issue = "Dangerous Capability",
                                details = "Container '$containerName' in deployment '$deploymentName' has dangerous capability: $capability"
                            ))
                        }
                    }

                    // Check for allowPrivilegeEscalation
                    if (securityContext?.allowPrivilegeEscalation == true) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = deploymentName,
                            containerName = containerName,
                            issue = "Privilege Escalation",
                            details = "Container '$containerName' in deployment '$deploymentName' allows privilege escalation"
                        ))
                    }

                    // Check for hostPath volumes
                    deployment.spec.template.spec.volumes?.forEach { volume ->
                        val hostPath = volume.hostPath
                        if (hostPath != null) {
                            val path = hostPath.path
                            val sensitivePaths = listOf(
                                "/", "/etc", "/var", "/var/run/docker.sock", "/var/lib/kubelet", 
                                "/var/lib/docker", "/run", "/dev"
                            )

                            sensitivePaths.forEach { sensitivePath ->
                                if (path != null && (path == sensitivePath || path.startsWith("$sensitivePath/"))) {
                                    findings.add(SecurityFinding(
                                        namespace = namespace,
                                        podName = deploymentName,
                                        containerName = containerName,
                                        issue = "Sensitive HostPath",
                                        details = "Deployment '$deploymentName' mounts sensitive host path: $path"
                                    ))
                                }
                            }
                        }
                    }
                }

                // Check for deployments with hostNetwork, hostPID, or hostIPC
                if (deployment.spec.template.spec.hostNetwork == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = deploymentName,
                        containerName = "N/A",
                        issue = "Host Network",
                        details = "Deployment '$deploymentName' uses host network namespace"
                    ))
                }

                if (deployment.spec.template.spec.hostPID == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = deploymentName,
                        containerName = "N/A",
                        issue = "Host PID",
                        details = "Deployment '$deploymentName' uses host PID namespace"
                    ))
                }

                if (deployment.spec.template.spec.hostIPC == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = deploymentName,
                        containerName = "N/A",
                        issue = "Host IPC",
                        details = "Deployment '$deploymentName' uses host IPC namespace"
                    ))
                }

                // Check for automountServiceAccountToken
                if (deployment.spec.template.spec.automountServiceAccountToken != false) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = deploymentName,
                        containerName = "N/A",
                        issue = "Automount ServiceAccount Token",
                        details = "Deployment '$deploymentName' does not disable automountServiceAccountToken"
                    ))
                }

                // Check for image pull secrets
                if (deployment.spec.template.spec.imagePullSecrets.isNullOrEmpty()) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = deploymentName,
                        containerName = "N/A",
                        issue = "Missing Image Pull Secrets",
                        details = "Deployment '$deploymentName' does not specify image pull secrets, which may use public images or default credentials"
                    ))
                }

            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing deployment: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Analyzes PersistentVolumeClaim resources for security concerns
     */
    private fun analyzePVCs(
        pvcs: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        pvcs.forEach { resource ->
            try {
                val pvc = config.importExportUtils.unmarshal<PersistentVolumeClaim>(resource)
                val namespace = pvc.metadata.namespace ?: "default"
                val pvcName = pvc.metadata.name

                // Check for PVCs with ReadWriteMany access mode
                if (pvc.spec.accessModes?.contains("ReadWriteMany") == true) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "ReadWriteMany PVC",
                        details = "PersistentVolumeClaim '$pvcName' uses ReadWriteMany access mode which allows multiple pods to mount the volume with read-write access",
                        resourceType = "PersistentVolumeClaim",
                        resourceName = pvcName
                    ))
                }

                // Check for PVCs without storage class
                if (pvc.spec.storageClassName.isNullOrEmpty()) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "PVC Without StorageClass",
                        details = "PersistentVolumeClaim '$pvcName' does not specify a storage class, which may use the default storage class with unintended permissions",
                        resourceType = "PersistentVolumeClaim",
                        resourceName = pvcName
                    ))
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing PVC: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Checks for PVCs that are not mounted by any pod
     */
    private fun checkUnmountedPVCs(
        pvcs: List<HasMetadata>,
        pods: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        // Create a set of all PVC names with their namespaces
        val allPVCs = mutableSetOf<Pair<String, String>>()
        pvcs.forEach { resource ->
            try {
                val pvc = config.importExportUtils.unmarshal<PersistentVolumeClaim>(resource)
                val namespace = pvc.metadata.namespace ?: "default"
                val pvcName = pvc.metadata.name
                allPVCs.add(Pair(namespace, pvcName))
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error processing PVC: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Create a set of all mounted PVC names with their namespaces
        val mountedPVCs = mutableSetOf<Pair<String, String>>()
        pods.forEach { resource ->
            try {
                val pod = config.importExportUtils.unmarshal<Pod>(resource)
                val namespace = pod.metadata.namespace ?: "default"

                // Check each volume in the pod
                pod.spec.volumes?.forEach { volume ->
                    // Check if the volume references a PVC
                    if (volume.persistentVolumeClaim != null) {
                        val pvcName = volume.persistentVolumeClaim.claimName
                        if (pvcName != null) {
                            mountedPVCs.add(Pair(namespace, pvcName))
                        }
                    }
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error processing pod volumes: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Find PVCs that are not mounted by any pod
        val unmountedPVCs = allPVCs - mountedPVCs

        // Add findings for unmounted PVCs
        unmountedPVCs.forEach { (namespace, pvcName) ->
            findings.add(SecurityFinding(
                namespace = namespace,
                podName = "N/A",
                containerName = "N/A",
                issue = "Unmounted PVC",
                details = "PersistentVolumeClaim '$pvcName' is not mounted by any pod and may be unused",
                resourceType = "PersistentVolumeClaim",
                resourceName = pvcName
            ))
        }

        config.prettyLogger.printlnInfo(message = "Found ${unmountedPVCs.size} unmounted PVCs")
    }

    /**
     * Analyzes Kyverno policy resources for security concerns
     */
    private fun analyzeKyvernoPolicies(
        kyvernoPolicies: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        kyvernoPolicies.forEach { resource ->
            try {
                val policyJson = Serialization.asJson(resource)
                val kind = resource.kind
                val name = resource.metadata.name
                val namespace = resource.metadata.namespace ?: "cluster-wide"

                // Check if this is a security policy
                val isSecurityPolicy = when {
                    policyJson.contains("privileged") -> true
                    policyJson.contains("hostPath") -> true
                    policyJson.contains("hostNetwork") -> true
                    policyJson.contains("hostPID") -> true
                    policyJson.contains("hostIPC") -> true
                    policyJson.contains("allowPrivilegeEscalation") -> true
                    policyJson.contains("runAsUser") -> true
                    policyJson.contains("runAsGroup") -> true
                    policyJson.contains("capabilities") -> true
                    policyJson.contains("securityContext") -> true
                    else -> false
                }

                // If it's a security policy, check if it's enforcing or just auditing
                if (isSecurityPolicy) {
                    val isEnforcing = policyJson.contains("enforce")

                    if (!isEnforcing) {
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = "N/A",
                            containerName = "N/A",
                            issue = "Non-Enforcing Security Policy",
                            details = "$kind '$name' appears to be a security policy but may not be enforcing (only auditing)",
                            resourceType = kind,
                            resourceName = name
                        ))
                    } else {
                        // This is a positive finding - a security policy that is enforcing
                        findings.add(SecurityFinding(
                            namespace = namespace,
                            podName = "N/A",
                            containerName = "N/A",
                            issue = "Security Policy",
                            details = "$kind '$name' is enforcing security controls",
                            resourceType = kind,
                            resourceName = name
                        ))
                    }
                } else {
                    // Not a security policy, but we'll note it for awareness
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Non-Security Policy",
                        details = "$kind '$name' does not appear to enforce security controls",
                        resourceType = kind,
                        resourceName = name
                    ))
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing Kyverno policy: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Analyzes Ingress resources for security concerns
     */
    private fun analyzeIngresses(
        ingresses: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        ingresses.forEach { resource ->
            try {
                val ingress = config.importExportUtils.unmarshal<Ingress>(resource)
                val namespace = ingress.metadata.namespace ?: "default"
                val ingressName = ingress.metadata.name

                // Check for Ingress without TLS
                if (ingress.spec.tls.isNullOrEmpty()) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Ingress Without TLS",
                        details = "Ingress '$ingressName' does not have TLS configured, which may expose traffic in plaintext",
                        resourceType = "Ingress",
                        resourceName = ingressName
                    ))
                }

                // Check for Ingress with default backend
                if (ingress.spec.backend != null) {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Ingress With Default Backend",
                        details = "Ingress '$ingressName' has a default backend configured, which may expose unintended services",
                        resourceType = "Ingress",
                        resourceName = ingressName
                    ))
                }

                // Check for Ingress annotations related to security
                val annotations = ingress.metadata.annotations ?: mapOf()

                // Check for missing security-related annotations
                if (!annotations.containsKey("nginx.ingress.kubernetes.io/ssl-redirect") || 
                    annotations["nginx.ingress.kubernetes.io/ssl-redirect"] != "true") {
                    findings.add(SecurityFinding(
                        namespace = namespace,
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Ingress Without SSL Redirect",
                        details = "Ingress '$ingressName' does not have SSL redirect enabled, which may allow insecure HTTP access",
                        resourceType = "Ingress",
                        resourceName = ingressName
                    ))
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing Ingress: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }
    }

    /**
     * Analyzes External Secrets Operator resources for security concerns
     */
    private fun analyzeExternalSecretsResources(
        clusterSecretStores: List<HasMetadata>,
        secretStores: List<HasMetadata>,
        externalSecrets: List<HasMetadata>,
        findings: MutableList<SecurityFinding>
    ) {
        // Check for ClusterSecretStore resources
        clusterSecretStores.forEach { resource ->
            try {
                val name = resource.metadata.name

                findings.add(SecurityFinding(
                    namespace = "cluster-wide",
                    podName = "N/A",
                    containerName = "N/A",
                    issue = "ClusterSecretStore Found",
                    details = "ClusterSecretStore '$name' detected. This resource configures access to external secret providers at the cluster level and should be reviewed for security implications.",
                    resourceType = "ClusterSecretStore",
                    resourceName = name
                ))

                // Check for specific providers in the ClusterSecretStore
                val resourceJson = Serialization.asJson(resource)

                // Check for AWS provider
                if (resourceJson.contains("provider") && resourceJson.contains("aws")) {
                    findings.add(SecurityFinding(
                        namespace = "cluster-wide",
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "AWS Secrets Provider",
                        details = "ClusterSecretStore '$name' uses AWS as a secrets provider. Ensure IAM roles and permissions are properly configured.",
                        resourceType = "ClusterSecretStore",
                        resourceName = name
                    ))
                }

                // Check for GCP provider
                if (resourceJson.contains("provider") && resourceJson.contains("gcpsm")) {
                    findings.add(SecurityFinding(
                        namespace = "cluster-wide",
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "GCP Secrets Provider",
                        details = "ClusterSecretStore '$name' uses Google Cloud Platform as a secrets provider. Ensure service accounts and permissions are properly configured.",
                        resourceType = "ClusterSecretStore",
                        resourceName = name
                    ))
                }

                // Check for Azure provider
                if (resourceJson.contains("provider") && resourceJson.contains("azure")) {
                    findings.add(SecurityFinding(
                        namespace = "cluster-wide",
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Azure Secrets Provider",
                        details = "ClusterSecretStore '$name' uses Azure as a secrets provider. Ensure managed identities and permissions are properly configured.",
                        resourceType = "ClusterSecretStore",
                        resourceName = name
                    ))
                }

                // Check for Vault provider
                if (resourceJson.contains("provider") && resourceJson.contains("vault")) {
                    findings.add(SecurityFinding(
                        namespace = "cluster-wide",
                        podName = "N/A",
                        containerName = "N/A",
                        issue = "Vault Secrets Provider",
                        details = "ClusterSecretStore '$name' uses HashiCorp Vault as a secrets provider. Ensure authentication methods and policies are properly configured.",
                        resourceType = "ClusterSecretStore",
                        resourceName = name
                    ))
                }

            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing ClusterSecretStore: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Check for SecretStore resources
        secretStores.forEach { resource ->
            try {
                val name = resource.metadata.name
                val namespace = resource.metadata.namespace ?: "default"

                findings.add(SecurityFinding(
                    namespace = namespace,
                    podName = "N/A",
                    containerName = "N/A",
                    issue = "SecretStore Found",
                    details = "SecretStore '$name' detected in namespace '$namespace'. This resource configures access to external secret providers and should be reviewed for security implications.",
                    resourceType = "SecretStore",
                    resourceName = name
                ))

            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing SecretStore: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // Check for ExternalSecret resources
        externalSecrets.forEach { resource ->
            try {
                val name = resource.metadata.name
                val namespace = resource.metadata.namespace ?: "default"

                findings.add(SecurityFinding(
                    namespace = namespace,
                    podName = "N/A",
                    containerName = "N/A",
                    issue = "ExternalSecret Found",
                    details = "ExternalSecret '$name' detected in namespace '$namespace'. This resource fetches secrets from external providers and injects them into Kubernetes as Secret objects.",
                    resourceType = "ExternalSecret",
                    resourceName = name
                ))

            } catch (e: Exception) {
                config.prettyLogger.printlnError(message = "Error analyzing ExternalSecret: ${e.message}")
                if (config.verbose) {
                    e.printStackTrace()
                }
            }
        }

        // If any External Secrets Operator resources were found, add a general finding
        if (clusterSecretStores.isNotEmpty() || secretStores.isNotEmpty() || externalSecrets.isNotEmpty()) {
            findings.add(SecurityFinding(
                namespace = "cluster-wide",
                podName = "N/A",
                containerName = "N/A",
                issue = "External Secrets Operator Detected",
                details = "External Secrets Operator is being used in the cluster. This operator allows fetching secrets from external APIs and injecting them into Kubernetes as Secret objects. Ensure proper security controls are in place for external secret providers.",
                resourceType = "Operator",
                resourceName = "ExternalSecretsOperator"
            ))
        }
    }

    private fun writeFindings(findings: List<SecurityFinding>, path: Path, format: FileFormat) {
        FileWriter(File(path.toString())).use { writer ->
            when (format) {
                FileFormat.CSV -> {
                    // Write CSV header
//                    writer.append("Namespace,Resource Type,Resource Name,Container,Issue,Details,Kubectl Command\n")
//
//                    // Write data rows
//                    findings.forEach { finding ->
//                        writer.append("${finding.namespace},${finding.resourceType},${finding.resourceName},${finding.containerName},${finding.issue},\"${finding.details}\",\"${finding.kubectlCommand}\"\n")
//                    }

                    writer.append(DataSerializer.toCsv(findings))
                }

                FileFormat.MARKDOWN -> {
                    // Write Markdown header
                    writer.append("# Kubernetes Security Analysis\n\n")
                    writer.append("## Security Findings\n\n")
                    writer.append(DataSerializer.toMarkdownTable(findings))
//                    writer.append("| Namespace | Resource Type | Resource Name | Container | Issue | Details | Kubectl Command |\n")
//                    writer.append("|-----------|--------------|---------------|-----------|-------|---------|----------------|\n")
//
//                    // Write data rows
//                    findings.forEach { finding ->
//                        writer.append("| ${finding.namespace} | ${finding.resourceType} | ${finding.resourceName} | ${finding.containerName} | ${finding.issue} | ${finding.details} | `${finding.kubectlCommand}` |\n")
//                    }

                    // Add summary
                    writer.append("\n## Summary\n\n")
                    writer.append("Total findings: ${findings.size}\n\n")

                    // Group by issue type
                    val issueGroups = findings.groupBy { it.issue }
                    writer.append("### Findings by Issue Type\n\n")
                    issueGroups.forEach { (issue, issueFindingsList) ->
                        writer.append("- $issue: ${issueFindingsList.size}\n")
                    }

                    // Group by namespace
                    val namespaceGroups = findings.groupBy { it.namespace }
                    writer.append("\n### Findings by Namespace\n\n")
                    namespaceGroups.forEach { (namespace, namespaceFindingsList) ->
                        writer.append("- $namespace: ${namespaceFindingsList.size}\n")
                    }
                }
            }
        }
    }
}
