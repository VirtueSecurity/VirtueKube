package com.nickcoblentz.kubepentest.commands

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.github.ajalt.clikt.parameters.types.long
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.kubepentest.models.KubePentestContext
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.batch.v1.Job
import io.fabric8.kubernetes.client.Watcher
import io.fabric8.kubernetes.client.WatcherException
import java.nio.file.Files
import java.time.Duration
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference
import kotlin.io.path.Path
import kotlin.io.path.absolutePathString
import kotlin.io.path.exists

/**
 * Command to test deployment of job-template.yaml and pod-template.yaml to the Kubernetes cluster.
 * This command deploys both templates, waits for them to complete, and prints status information and logs.
 */
class TestDeployment : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = 
        "${(TextColors.green)("(online)")} Test deployment of job-template.yaml and pod-template.yaml to the Kubernetes cluster"

    private val namespaceOption by option("-n", "--namespace", help = "Namespace to deploy to").required()
    private val jobTemplateOption by option("-j", "--job-template", help = "Job template file").default("testCases/job-template.yaml")
    private val podTemplateOption by option("-p", "--pod-template", help = "Pod template file").default("testCases/pod-template.yaml")
    private val timeoutOption by option("-t", "--timeout", help = "Timeout in seconds for waiting for deployments").long().default(180)

    private val config by requireObject<KubePentestContext>()

    init {
        this.installMordantMarkdown()
    }

    override fun run() {

        // Deploy job template
        deployJobTemplate()

        // Deploy pod template
        deployPodTemplate()
    }

    private fun deployJobTemplate() {
        val jobPath = Path(jobTemplateOption)
        if (!jobPath.exists()) {
            config.prettyLogger.printlnError(title = "Error", message = "Job template file not found: ${jobPath.absolutePathString()}")
            return
        }

        config.prettyLogger.printlnInfo(title = "Job Template", message = "Loading ${jobPath.absolutePathString()}")
        val jobTemplateYaml = Files.readString(jobPath)

        // Create a unique name for the job
        val jobName = "test-job-${System.currentTimeMillis()}"

        try {
            // Load and modify the job template
            val job = config.k8s.batch().v1().jobs().load(jobTemplateYaml.byteInputStream()).item()
            job.metadata.name = jobName

            // Deploy the job
            config.prettyLogger.printlnInfo(title = "Job", message = "Deploying job $jobName to namespace $namespaceOption")
            val createdJob = config.k8s.batch().v1().jobs().inNamespace(namespaceOption).resource(job).create()

            // Wait for the job to complete and monitor its status
            waitForJobCompletion(createdJob)

            // Print job status
            val finalJob = config.k8s.batch().v1().jobs().inNamespace(namespaceOption).withName(jobName).get()
            printJobStatus(finalJob)

            // Get and print pod logs for the job
            val jobPods = config.k8s.pods().inNamespace(namespaceOption)
                .withLabel("job-name", jobName)
                .list()
                .items

            if (jobPods.isNotEmpty()) {
                val pod = jobPods[0]
                config.prettyLogger.printlnInfo(title = "Job Pod", message = "Found pod ${pod.metadata.name} for job $jobName")
                printPodStatus(pod)
                printPodLogs(pod)
            } else {
                config.prettyLogger.printlnWarning(title = "Warning", message = "No pods found for job $jobName")
            }

        } catch (e: Exception) {
            config.prettyLogger.printlnError(title = "Error", message = "Failed to deploy job template: ${e.message}")
            e.printStackTrace()
        }
    }

    private fun deployPodTemplate() {
        val podPath = Path(podTemplateOption)
        if (!podPath.exists()) {
            config.prettyLogger.printlnError(title = "Error", message = "Pod template file not found: ${podPath.absolutePathString()}")
            return
        }

        config.prettyLogger.printlnInfo(title = "Pod Template", message = "Loading ${podPath.absolutePathString()}")
        val podTemplateYaml = Files.readString(podPath)

        // Create a unique name for the pod
        val podName = "test-pod-${System.currentTimeMillis()}"

        try {
            // Load and modify the pod template
            val pod = config.k8s.pods().load(podTemplateYaml.byteInputStream()).item()
            pod.metadata.name = podName

            // Deploy the pod
            config.prettyLogger.printlnInfo(title = "Pod", message = "Deploying pod $podName to namespace $namespaceOption")
            val createdPod = config.k8s.pods().inNamespace(namespaceOption).resource(pod).create()

            // Wait for the pod to complete and monitor its status
            waitForPodCompletion(createdPod)

            // Print pod status
            val finalPod = config.k8s.pods().inNamespace(namespaceOption).withName(podName).get()
            printPodStatus(finalPod)

            // Print pod logs
            printPodLogs(finalPod)

        } catch (e: Exception) {
            config.prettyLogger.printlnError(title = "Error", message = "Failed to deploy pod template: ${e.message}")
            e.printStackTrace()
        }
    }

    private fun waitForJobCompletion(job: Job) {
        val jobName = job.metadata.name
        val jobCompleted = AtomicBoolean(false)
        val jobSucceeded = AtomicBoolean(false)
        val jobFailureReason = AtomicReference<String?>(null)

        val jobWatcher = object : Watcher<Job> {
            override fun eventReceived(action: Watcher.Action, resource: Job) {
                if (resource.metadata.name == jobName) {
                    val status = resource.status
                    val succeeded = status?.succeeded ?: 0
                    val failed = status?.failed ?: 0
                    val active = status?.active ?: 0

                    config.prettyLogger.printlnInfo(
                        title = "Job '$jobName'",
                        message = "Status: Active=$active, Succeeded=$succeeded, Failed=$failed"
                    )

                    if (succeeded > 0) {
                        config.prettyLogger.printlnInfo(message = "Job '$jobName' succeeded.")
                        jobSucceeded.set(true)
                        jobCompleted.set(true)
                    } else if (failed > 0) {
                        config.prettyLogger.printlnInfo(title = "Job '$jobName' failed", message = "Job failed")
                        jobFailureReason.set("Job failed")
                        jobCompleted.set(true)
                    }
                }
            }

            override fun onClose(cause: WatcherException?) {
                if (cause != null) {
                    config.prettyLogger.printlnInfo(message = "Job Watcher closed with exception: ${cause.message}")
                    jobCompleted.set(true)
                    jobSucceeded.set(false)
                    jobFailureReason.set("Watcher closed unexpectedly: ${cause.message}")
                }
            }
        }

        // Start a thread to monitor the job
        val monitorThread = Thread.startVirtualThread {
            config.k8s.batch().v1().jobs().inNamespace(namespaceOption).withName(jobName).watch(jobWatcher).use { watcher ->
                val startTime = System.currentTimeMillis()
                val timeoutMillis = timeoutOption * 1000

                while (!jobCompleted.get()) {
                    if (System.currentTimeMillis() - startTime > timeoutMillis) {
                        config.prettyLogger.printlnWarning(title = "Timeout", message = "Job '$jobName' did not complete within ${timeoutOption} seconds")
                        jobCompleted.set(true)
                        break
                    }
                    Thread.sleep(1000)
                }
            }
        }

        // Wait for the monitor thread to complete
        monitorThread.join()

        if (jobSucceeded.get()) {
            config.prettyLogger.printlnInfo(title = "Success", message = "Job '$jobName' completed successfully")
        } else if (jobFailureReason.get() != null) {
            config.prettyLogger.printlnWarning(title = "Failure", message = "Job '$jobName' failed: ${jobFailureReason.get()}")
        } else {
            config.prettyLogger.printlnWarning(title = "Unknown", message = "Job '$jobName' status is unknown")
        }
    }

    private fun waitForPodCompletion(pod: Pod) {
        val podName = pod.metadata.name
        val podCompleted = AtomicBoolean(false)
        val podSucceeded = AtomicBoolean(false)
        val podFailureReason = AtomicReference<String?>(null)

        val podWatcher = object : Watcher<Pod> {
            override fun eventReceived(action: Watcher.Action, resource: Pod) {
                if (resource.metadata.name == podName) {
                    val phase = resource.status?.phase

                    config.prettyLogger.printlnInfo(
                        title = "Pod '$podName'",
                        message = "Status: Phase=$phase"
                    )

                    if (phase == "Succeeded") {
                        config.prettyLogger.printlnInfo(message = "Pod '$podName' succeeded.")
                        podSucceeded.set(true)
                        podCompleted.set(true)
                    } else if (phase == "Failed") {
                        val reason = resource.status?.reason ?: "Unknown reason"
                        config.prettyLogger.printlnInfo(title = "Pod '$podName' failed", message = "Reason: $reason")
                        podFailureReason.set(reason)
                        podCompleted.set(true)
                    }
                }
            }

            override fun onClose(cause: WatcherException?) {
                if (cause != null) {
                    config.prettyLogger.printlnInfo(message = "Pod Watcher closed with exception: ${cause.message}")
                    podCompleted.set(true)
                    podSucceeded.set(false)
                    podFailureReason.set("Watcher closed unexpectedly: ${cause.message}")
                }
            }
        }

        // Start a thread to monitor the pod
        val monitorThread = Thread.startVirtualThread {
            config.k8s.pods().inNamespace(namespaceOption).withName(podName).watch(podWatcher).use { watcher ->
                val startTime = System.currentTimeMillis()
                val timeoutMillis = timeoutOption * 1000

                while (!podCompleted.get()) {
                    if (System.currentTimeMillis() - startTime > timeoutMillis) {
                        config.prettyLogger.printlnWarning(title = "Timeout", message = "Pod '$podName' did not complete within ${timeoutOption} seconds")
                        podCompleted.set(true)
                        break
                    }
                    Thread.sleep(1000)
                }
            }
        }

        // Wait for the monitor thread to complete
        monitorThread.join()

        if (podSucceeded.get()) {
            config.prettyLogger.printlnInfo(title = "Success", message = "Pod '$podName' completed successfully")
        } else if (podFailureReason.get() != null) {
            config.prettyLogger.printlnWarning(title = "Failure", message = "Pod '$podName' failed: ${podFailureReason.get()}")
        } else {
            config.prettyLogger.printlnWarning(title = "Unknown", message = "Pod '$podName' status is unknown")
        }
    }

    private fun printJobStatus(job: Job) {
        config.prettyLogger.printlnInfo(title = "Job Status", message = "Name: ${job.metadata.name}")

        val status = job.status
        if (status != null) {
            config.prettyLogger.printlnInfo(message = "  Active: ${status.active ?: 0}")
            config.prettyLogger.printlnInfo(message = "  Succeeded: ${status.succeeded ?: 0}")
            config.prettyLogger.printlnInfo(message = "  Failed: ${status.failed ?: 0}")
            config.prettyLogger.printlnInfo(message = "  Completion Time: ${status.completionTime ?: "N/A"}")
            config.prettyLogger.printlnInfo(message = "  Start Time: ${status.startTime ?: "N/A"}")

            // Calculate duration if both start and completion times are available
            if (status.startTime != null && status.completionTime != null) {
                // Just print the raw times since we can't easily calculate duration
                config.prettyLogger.printlnInfo(message = "  Duration: From ${status.startTime} to ${status.completionTime}")
            }
        } else {
            config.prettyLogger.printlnWarning(message = "  No status information available")
        }
    }

    private fun printPodStatus(pod: Pod) {
        config.prettyLogger.printlnInfo(title = "Pod Status", message = "Name: ${pod.metadata.name}")

        val status = pod.status
        if (status != null) {
            config.prettyLogger.printlnInfo(message = "  Phase: ${status.phase ?: "Unknown"}")
            config.prettyLogger.printlnInfo(message = "  Host IP: ${status.hostIP ?: "N/A"}")
            config.prettyLogger.printlnInfo(message = "  Pod IP: ${status.podIP ?: "N/A"}")
            config.prettyLogger.printlnInfo(message = "  Start Time: ${status.startTime ?: "N/A"}")

            // Print container statuses
            status.containerStatuses?.forEach { containerStatus ->
                config.prettyLogger.printlnInfo(message = "  Container: ${containerStatus.name}")
                config.prettyLogger.printlnInfo(message = "    Ready: ${containerStatus.ready}")
                config.prettyLogger.printlnInfo(message = "    Restart Count: ${containerStatus.restartCount}")

                // Print state details
                val state = containerStatus.state
                if (state != null) {
                    when {
                        state.running != null -> config.prettyLogger.printlnInfo(
                            message = "    State: Running (since ${state.running.startedAt})"
                        )
                        state.terminated != null -> config.prettyLogger.printlnInfo(
                            message = "    State: Terminated (exit code: ${state.terminated.exitCode}, reason: ${state.terminated.reason})"
                        )
                        state.waiting != null -> config.prettyLogger.printlnInfo(
                            message = "    State: Waiting (reason: ${state.waiting.reason})"
                        )
                    }
                }
            }

            // Print conditions
            status.conditions?.forEach { condition ->
                config.prettyLogger.printlnInfo(
                    message = "  Condition: ${condition.type} (Status: ${condition.status}, Reason: ${condition.reason ?: "N/A"})"
                )
            }
        } else {
            config.prettyLogger.printlnWarning(message = "  No status information available")
        }
    }

    private fun printPodLogs(pod: Pod) {
        val podName = pod.metadata.name

        config.prettyLogger.printlnInfo(title = "Pod Logs", message = "Name: $podName")

        // Get logs for each container in the pod
        pod.spec.containers.forEach { container ->
            val containerName = container.name
            try {
                val logs = config.k8s.pods()
                    .inNamespace(namespaceOption)
                    .withName(podName)
                    .inContainer(containerName)
                    .getLog()

                config.prettyLogger.printlnInfo(title = "Container: $containerName", message = "Logs:")
                if (logs.isNotBlank()) {
                    config.prettyLogger.printlnInfo(message = logs)
                } else {
                    config.prettyLogger.printlnInfo(message = "  No logs available")
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnWarning(
                    title = "Warning",
                    message = "Failed to get logs for container $containerName: ${e.message}"
                )
            }
        }

        // Get logs for each init container in the pod
        pod.spec.initContainers?.forEach { container ->
            val containerName = container.name
            try {
                val logs = config.k8s.pods()
                    .inNamespace(namespaceOption)
                    .withName(podName)
                    .inContainer(containerName)
                    .getLog()

                config.prettyLogger.printlnInfo(title = "Init Container: $containerName", message = "Logs:")
                if (logs.isNotBlank()) {
                    config.prettyLogger.printlnInfo(message = logs)
                } else {
                    config.prettyLogger.printlnInfo(message = "  No logs available")
                }
            } catch (e: Exception) {
                config.prettyLogger.printlnWarning(
                    title = "Warning",
                    message = "Failed to get logs for init container $containerName: ${e.message}"
                )
            }
        }
    }
}
