package com.nickcoblentz.kubepentest.commands

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.kubepentest.models.KubePentestContext
import io.fabric8.kubernetes.api.model.HasMetadata
import io.fabric8.kubernetes.api.model.Pod
import java.nio.file.Files
import java.nio.file.Path
import java.time.Duration
import kotlin.io.path.createDirectories
import kotlin.io.path.exists

class ReportKustomizeTestCases : CliktCommand() {
    override fun help(context: com.github.ajalt.clikt.core.Context) = "${(TextColors.green)("(online)")} Run generated kustomize pod test cases and produce Markdown/CSV/JSON reports"

    private val config by requireObject<KubePentestContext>()

    private val namespaceOption by option("-n", "--namespace", help = "Namespace to deploy the nmap job to").required()

    init { installMordantMarkdown() }

    data class Row(
        val title: String,
        val description: String,
        val expectedResult: String,
        val actualResult: String,
        val references: String,
        val resourceFile: String,
        val deployOutputFile: String,
        val containerLogs: String,
        val initContainerLogs: String,
        val podYaml: String
    )

    override fun run() {
        val pretty = config.prettyLogger
        val outputDir = config.testCaseResultsDirectoryPath("kustomize")
        pretty.printlnInfo(message = "Looking for test cases in *.yaml files at ${outputDir.toAbsolutePath()}")
        if (!outputDir.exists()) {
            pretty.printlnError(message = "Directory ${outputDir.toAbsolutePath()} does not exist. Run GenerateKustomizeTestCases first.")
            return
        }

        val runsDir = outputDir.resolve("runs").also { if (!Files.exists(it)) Files.createDirectories(it) }

        val rows = mutableListOf<Row>()

        Files.newDirectoryStream(outputDir) { p ->
            Files.isRegularFile(p) && p.toString().endsWith(".yaml")
        }.use { stream ->
            stream.forEach { yamlPath ->
                try {
                    processYaml(yamlPath, runsDir)?.let { rows.add(it) }
                } catch (e: Exception) {
                    pretty.printlnError(title = "Error", message = "Failed processing ${yamlPath.fileName}: ${e.message}")
                }
            }
        }

        // Write reports
        val mdPath = outputDir.resolve("report.md")
        val csvPath = outputDir.resolve("report.csv")
        val jsonPath = outputDir.resolve("report.json")

        val md = buildMarkdown(rows)
        Files.writeString(mdPath, md)

        Files.writeString(csvPath, toCsv(rows))
        Files.writeString(jsonPath, toJson(rows))

        pretty.printlnSuccess(title = "Reports", message = "Written: ${mdPath.toAbsolutePath()}\n${csvPath.toAbsolutePath()}\n${jsonPath.toAbsolutePath()}")
    }

    private fun processYaml(yamlPath: Path, runsDir: Path): Row? {
        val k8s = config.k8s
        val yaml = Files.readString(yamlPath)
        val list = k8s.resourceList(yaml).items()
        val podRes: HasMetadata? = list.firstOrNull { it.kind.equals("Pod", ignoreCase = true) }
        if (podRes == null) return null
        val pod = config.importExportUtils.unmarshal<Pod>(podRes)

        val annotations = pod.metadata?.annotations ?: emptyMap()
        val title = annotations["virtuekube.io/test-title"] ?: yamlPath.fileName.toString().removeSuffix(".yaml")
        val description = annotations["virtuekube.io/test-description"] ?: ""
        val expected = annotations["virtuekube.io/test-expected-result"] ?: ""
        val references = annotations["virtuekube.io/test-references"] ?: ""
        var generatedPodYaml = ""

        config.prettyLogger.printlnInfo(message = "Deploying pod $title to namespace $namespaceOption")
        //val ns = (pod.metadata?.namespace ?: k8s.configuration?.currentContext?.context?.namespace) ?: "default"

        // Prepare pod name unique
        val baseName = (pod.metadata?.name ?: title.lowercase().replace("[^a-z0-9-]".toRegex(), "-").trim('-'))
        val uniqueName = listOf(baseName, System.currentTimeMillis().toString()).joinToString("-")
        pod.metadata.name = uniqueName
        pod.metadata.namespace = namespaceOption

        val perRunDir = runsDir.resolve(safeFileName(title)).resolve(uniqueName)
        perRunDir.createDirectories()
        val deployOutFile = perRunDir.resolve("deploy-output.txt")
        val podYamlPath = perRunDir.resolve("pod.yaml")

        var actual = false
        val logPathsContainers = mutableListOf<Path>()
        val logPathsInit = mutableListOf<Path>()
        var created = false

        try {
            val createdPod = k8s.pods().inNamespace(namespaceOption).resource(pod).create()
            created = createdPod != null
            actual = created
            Files.writeString(deployOutFile, "Created pod ${createdPod?.metadata?.name} in namespace $namespaceOption\n")

            // Wait a short while for containers to start
            waitForPodPhase(namespaceOption, uniqueName, Duration.ofSeconds(15))

            // Save logs for init containers
            createdPod?.spec?.initContainers?.forEach { c ->
                val log = runCatching { k8s.pods().inNamespace(namespaceOption).withName(uniqueName).inContainer(c.name).getLog(true) }.getOrElse { it.message ?: "" }
                val path = perRunDir.resolve("initcontainer-${c.name}.log")
                Files.writeString(path, log)
                logPathsInit.add(path)
            }
            // Save logs for app containers
            createdPod?.spec?.containers?.forEach { c ->
                val log = runCatching { k8s.pods().inNamespace(namespaceOption).withName(uniqueName).inContainer(c.name).getLog(true) }.getOrElse { it.message ?: "" }
                val path = perRunDir.resolve("container-${c.name}.log")
                Files.writeString(path, log)
                logPathsContainers.add(path)
            }
        } catch (e: Exception) {
            actual = false
            Files.writeString(deployOutFile, "Deploy error: ${e.message}\n")
            runCatching { retrievePodYaml(namespaceOption, uniqueName, podYamlPath)?.let { generatedPodYaml = it} }
        } finally {
            // Snapshot pod YAML if exists before deletion
            runCatching { retrievePodYaml(namespaceOption, uniqueName, podYamlPath)?.let { generatedPodYaml = it} }
            // Cleanup pod if created
            if (created) {
                runCatching { config.k8s.pods().inNamespace(namespaceOption).withName(uniqueName).delete() }
            }
        }

        return Row(
            title = title,
            description = description,
            expectedResult = expected,
            actualResult = actual.toString(),
            references = references,
            resourceFile = yamlPath.toString(),
            deployOutputFile = outputRel(deployOutFile),
            containerLogs = logPathsContainers.joinToString("; ") { outputRel(it) },
            initContainerLogs = logPathsInit.joinToString("; ") { outputRel(it) },
            podYaml = generatedPodYaml
        )
    }

    private fun retrievePodYaml(ns: String, name: String, dest: Path) : String? {
        val p = runCatching { config.k8s.pods().inNamespace(ns).withName(name).get() }.getOrNull()
        if (p != null) {
            val yaml = runCatching { config.importExportUtils.serializeToYamlString(p) }.getOrNull()
            return yaml
        }
        return null
    }

    private fun waitForPodPhase(ns: String, name: String, timeout: Duration) {
        val deadline = System.currentTimeMillis() + timeout.toMillis()
        while (System.currentTimeMillis() < deadline) {
            val p = runCatching { config.k8s.pods().inNamespace(ns).withName(name).get() }.getOrNull()
            val phase = p?.status?.phase ?: ""
            if (phase.equals("Running", true) || phase.equals("Succeeded", true) || phase.equals("Failed", true)) return
            Thread.sleep(1000)
        }
    }

    private fun buildMarkdown(rows: List<Row>): String {
        val sb = StringBuilder()
        sb.appendLine("# Kustomize Test Case Report")
        sb.appendLine()
        sb.appendLine("Generated at: ${java.time.ZonedDateTime.now()}")
        sb.appendLine()

        // Summary table
        sb.appendLine("| Title | Expected | Actual | References |")
        sb.appendLine("|---|---:|---:|---|")
        rows.forEach { r ->
            val anchor = "log-" + safeFileName(r.title)
            val linkTitle = "[${escapePipe(r.title)}](#${anchor})"
            sb.appendLine("| ${linkTitle} | ${r.expectedResult} | ${r.actualResult} | ${escapePipe(r.references)} |")
        }
        sb.appendLine()

        // Logs and detailed outputs
        sb.appendLine("## Logs and Outputs")
        sb.appendLine()
        rows.forEach { r ->
            val anchor = "log-" + safeFileName(r.title)
            sb.appendLine("### ${r.title}")
            sb.appendLine("<a id=\"${anchor}\"></a>")
            if (r.description.isNotBlank()) sb.appendLine(r.description)
            sb.appendLine()
            sb.appendLine("- Expected Result: ${r.expectedResult}")
            sb.appendLine("- Actual Result: ${r.actualResult}")
            if (r.references.isNotBlank()) sb.appendLine("- References: ${r.references}")
            sb.appendLine("- Resource File: ${r.resourceFile}")
            sb.appendLine()

            // Embed deploy output
            val deployPath = r.deployOutputFile
            if (deployPath.isNotBlank()) {
                val deployAbs = config.dataDirectoryBasePath(deployPath)
                val deployText = runCatching { Files.readString(deployAbs) }.getOrElse { it.message ?: "" }
                sb.appendLine("#### Deploy Output")
                sb.appendLine("```text")
                sb.appendLine(deployText)
                sb.appendLine("```")
                sb.appendLine()
            }

            // Embed container logs
            if (r.containerLogs.isNotBlank()) {
                sb.appendLine("#### Container Logs")
                r.containerLogs.split("; ").filter { it.isNotBlank() }.forEach { p ->
                    val abs = config.dataDirectoryBasePath(p)
                    val txt = runCatching { Files.readString(abs) }.getOrElse { it.message ?: "" }
                    sb.appendLine("##### ${abs.fileName}")
                    sb.appendLine("```text")
                    sb.appendLine(txt)
                    sb.appendLine("```")
                }
                sb.appendLine()
            }

            // Embed initContainer logs
            if (r.initContainerLogs.isNotBlank()) {
                sb.appendLine("#### InitContainer Logs")
                r.initContainerLogs.split("; ").filter { it.isNotBlank() }.forEach { p ->
                    val abs = config.dataDirectoryBasePath(p)
                    val txt = runCatching { Files.readString(abs) }.getOrElse { it.message ?: "" }
                    sb.appendLine("##### ${abs.fileName}")
                    sb.appendLine("```text")
                    sb.appendLine(txt)
                    sb.appendLine("```")
                }
                sb.appendLine()
            }

            // Embed Pod YAML snapshot
            if (r.podYaml.isNotBlank()) {
                sb.appendLine("#### Pod YAML Snapshot")
                sb.appendLine("```yaml")
                sb.appendLine(r.podYaml.trim() + "\n")
                sb.appendLine("```")
                sb.appendLine()
            }
        }

        return sb.toString()
    }

    private fun toCsv(rows: List<Row>): String {
        val header = listOf("title","description","expectedResult","actualResult","references","resourceFile","deployOutputFile","containerLogs","initContainerLogs","podYamlFile")
        val sb = StringBuilder()
        sb.appendLine(header.joinToString(","))
        rows.forEach { r ->
            sb.appendLine(listOf(r.title, r.description, r.expectedResult, r.actualResult, r.references, r.resourceFile, r.deployOutputFile, r.containerLogs, r.initContainerLogs, r.podYaml).joinToString(",") { escapeCsv(it) })
        }
        return sb.toString()
    }

    private fun toJson(rows: List<Row>): String {
        // Minimal dependency: build simple JSON manually to avoid introducing a new serializer here
        // The project already uses DataSerializer elsewhere, but to keep this isolated we'll output a straightforward JSON array
        val escaped = rows.joinToString(",\n  ") { r ->
            "{" +
                "\"title\":${jsonStr(r.title)}," +
                "\"description\":${jsonStr(r.description)}," +
                "\"expectedResult\":${jsonStr(r.expectedResult)}," +
                "\"actualResult\":${jsonStr(r.actualResult)}," +
                "\"references\":${jsonStr(r.references)}," +
                "\"resourceFile\":${jsonStr(r.resourceFile)}," +
                "\"deployOutputFile\":${jsonStr(r.deployOutputFile)}," +
                "\"containerLogs\":${jsonStr(r.containerLogs)}," +
                "\"initContainerLogs\":${jsonStr(r.initContainerLogs)}," +
                "\"podYamlFile\":${jsonStr(r.podYaml)}" +
            "}"
        }
        return "[\n  $escaped\n]"
    }

    private fun jsonStr(s: String) = "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n") + "\""

    private fun escapeCsv(s: String): String {
        var v = s.replace("\r", " ").replace("\n", " ")
        if (v.contains(",") || v.contains("\"") || v.contains("\n")) {
            v = v.replace("\"", "\"\"")
            v = "\"$v\""
        }
        return v
    }

    private fun escapePipe(s: String): String = s.replace("|", "\\|")

    private fun safeFileName(name: String): String = name.lowercase().replace("[^a-z0-9-_]".toRegex(), "-")

    private fun outputRel(path: Path): String {
        // Return path relative to the main output directory for nicer links
        val base = config.dataDirectoryBasePath().toAbsolutePath().normalize()
        val abs = path.toAbsolutePath().normalize()
        return base.relativize(abs).toString()
    }
}
