package com.nickcoblentz.kubepentest.commands

import com.fasterxml.jackson.annotation.JsonProperty
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.Context
import com.github.ajalt.clikt.core.installMordantMarkdown
import com.github.ajalt.clikt.core.requireObject
import com.github.ajalt.mordant.rendering.TextColors
import com.nickcoblentz.data.CsvColumnMapping
import com.nickcoblentz.data.DataSerializer
import com.nickcoblentz.kubepentest.models.KubePentestContext
import com.nickcoblentz.kubepentest.utils.ProductEOLChecker
import com.nickcoblentz.kubepentest.utils.endOfLifeProductVersionPair
import de.gesellix.docker.client.DockerClient
import de.gesellix.docker.client.DockerClientImpl
import de.gesellix.docker.remote.api.CreateImageInfo
import de.gesellix.docker.remote.api.HistoryResponseItem
import de.gesellix.docker.remote.api.ImageInspect
import de.gesellix.docker.remote.api.core.StreamCallback
import io.fabric8.kubernetes.api.model.ContainerStatus
import io.fabric8.kubernetes.api.model.Pod
import kotlin.io.path.absolutePathString
import kotlin.io.path.writeText
import kotlin.time.Duration.Companion.minutes
import kotlin.time.toJavaDuration

/**
 * Command to extract pod images from the cluster.
 */
class PodImages : CliktCommand() {
    override fun help(context: Context) = "${(TextColors.green)("(online)")} Extract Pod images, generate trivy commands, pull images from the repo (requires `docker login` already set up)"
    private val config by requireObject<KubePentestContext>()
    private val versionRegex = Regex("([0-9]+\\.[0-9]+\\.[0-9]+(-\\w+)?)")

    init {
        this.installMordantMarkdown()
    }

    private fun buildPodContainerImageFromStatus(pod : Pod, containerType : ContainerType, containerStatus: ContainerStatus) : PodContainerImage {

            val containerImage = PodContainerImage(
                pod.metadata.namespace,
                pod.metadata.name,
                containerType = containerType,
                podCreationTimestamp = pod.metadata.creationTimestamp,
                podPhase = pod.status.phase,
                imageName = containerStatus.image,
                imageID = containerStatus.imageID,
                imageTags = null,
                buildHistory = null,
                environmentVariables = null
            )

            return containerImage
    }

    override fun run() {
        val deserializeResources = config.importExportUtils.deserializeFromFile(config.byResourceDataDirectoryPath("Pod.json").toString())
        val pods = deserializeResources.filter { it.kind == "Pod" }.map { config.importExportUtils.unmarshal<Pod>(it) }

        val podContainerImages = mutableListOf<PodContainerImage>()
        pods.forEach { pod ->

            pod.status.containerStatuses.forEach { containerStatus ->
                podContainerImages.add(buildPodContainerImageFromStatus(pod, ContainerType.CONTAINER, containerStatus))
            }

            pod.status.initContainerStatuses.forEach { containerStatus ->
                podContainerImages.add(buildPodContainerImageFromStatus(pod, ContainerType.INIT_CONTAINER, containerStatus))
            }

            pod.status.ephemeralContainerStatuses.forEach { containerStatus ->
                podContainerImages.add(buildPodContainerImageFromStatus(pod, ContainerType.EPHEMERAL_CONTAINER, containerStatus))
            }
        }





        val pullTimeout = 5
        podContainerImages.forEach { podContainerImage ->

            try {
                val dockerClient: DockerClient = DockerClientImpl()
                config.prettyLogger.printlnInfo("Pulling image","${podContainerImage.imageID} (${podContainerImage.imageName}) (Timeout: $pullTimeout minutes)...")
                    // Use the pull method with a callback and a timeout, as per the specified signature.
                    dockerClient.pull(object : StreamCallback<CreateImageInfo> {
                        override fun onNext(event: CreateImageInfo?) {
                            if (event?.status == "Downloading" || event?.status == "Extracting") {
                                // Only print a dot if progress is actually being made
                                event.progressDetail?.let {
                                    if (it.current != null && it.total != null && it.current!! < it.total!!) {
                                        print(".")
                                    }
                                }
                            }
                        }

                        override fun onFinished() {
                            // A newline is added after the dots for clean formatting.
                            println()
                        }

                        override fun onFailed(e: Exception?) {
                            println("\nError during image pull: ${e?.message}")
                        }
                    }, pullTimeout.minutes.toJavaDuration(), podContainerImage.imageID)


                    println("Inspecting image...")
                    val inspect = dockerClient.inspectImage(podContainerImage.imageID).content
                    val history = dockerClient.history(podContainerImage.imageID).content
                    val inspectTags = getTags(history)
                    val buildHistory = getBuildHistory(history)
                    val envVars = getEnvVars(inspect)

                    podContainerImage.imageTags = inspectTags
                    podContainerImage.buildHistory = buildHistory
                    podContainerImage.environmentVariables = envVars

                    //TODO: Fix find base container image and version - more like export
                    findBaseContainerImageAndVersion(podContainerImage,inspect, history, inspectTags, envVars)
                    checkSoftwareVersions(podContainerImage)

            }
            catch (ex: Exception) {
                config.prettyLogger.printlnError("Docker image version collection failed: ${ex.message}\n${ex.stackTraceToString()}")
            }
        }

        val trivyCommandBuilder = mutableSetOf<String>()
        podContainerImages.forEach { podContainerImage ->
            trivyCommandBuilder.add("trivy image \"${podContainerImage.imageID}\"")
        }


        var outputPath = config.imagesDirectoryPath("trivycommands.txt")
        outputPath.writeText(trivyCommandBuilder.joinToString("\n"))
        config.prettyLogger.printlnSuccess(message = "Trivy Commands Saved to: ${outputPath.absolutePathString()}")


        outputPath = config.imagesDirectoryPath("images.csv")
        outputPath.writeText(DataSerializer.toCsv(podContainerImages))
        config.prettyLogger.printlnSuccess(message = "Exported Container Images to: ${outputPath.absolutePathString()}")

        outputPath = config.imagesDirectoryPath("images.json")
        outputPath.writeText(DataSerializer.toJson(podContainerImages))
        config.prettyLogger.printlnSuccess(message = "Exported Container Images to: ${outputPath.absolutePathString()}")

        val markdownBuilder = buildString {
            appendLine("# Container Images")
            appendLine(DataSerializer.toMarkdownTable(podContainerImages))
            podContainerImages.forEach { podContainerImage ->
                appendLine("## ${podContainerImage.imageName}")
                appendLine("- **Namespace**: ${podContainerImage.namespace}")
                appendLine("- **Pod Name**: ${podContainerImage.podName}")
                appendLine("- **Container Type**: ${podContainerImage.containerType}")
                appendLine("- **Creation Time**: ${podContainerImage.podCreationTimestamp}")
                appendLine("- **Pod Phase**: ${podContainerImage.podPhase}")
                appendLine("- **Image Name**: ${podContainerImage.imageName}")
                appendLine("- **Image ID**: ${podContainerImage.imageID}")
                appendLine("### Build History\n```\n${podContainerImage.buildHistory?.joinToString("\n")}\n```\n")
                appendLine("### Environment Variables\n```\n${podContainerImage.environmentVariables?.map { "${it.key}=${it.value}" }?.joinToString("\n")}\n```\n")
                appendLine("### Tags\n```\n${podContainerImage.imageTags?.joinToString("\n")}\n```\n")
                appendLine("### Software Versions")
                appendLine(DataSerializer.toMarkdownTable(podContainerImage.discoveredVersions))

                outputPath = config.tagDirectoryPath("${podContainerImage.filenamePrefix()}-tags.txt")
                outputPath.writeText(podContainerImage.imageTags?.joinToString("\n") ?: "")
                config.prettyLogger.printlnSuccess(message = "Exported Container Tags to: ${outputPath.absolutePathString()}")

                outputPath = config.historyDirectoryPath("${podContainerImage.filenamePrefix()}-history.txt")
                outputPath.writeText(podContainerImage.buildHistory?.joinToString("\n") ?: "")
                config.prettyLogger.printlnSuccess(message = "Exported Container History to: ${outputPath.absolutePathString()}")

                outputPath = config.envVarsDirectoryPath("${podContainerImage.filenamePrefix()}-envvars.txt")
                outputPath.writeText(podContainerImage.environmentVariables?.map { "${it.key}=${it.value}" }?.joinToString("\n") ?: "")
                config.prettyLogger.printlnSuccess(message = "Exported Container Environment Variables to: ${outputPath.absolutePathString()}")

            }
        }
        outputPath = config.imagesDirectoryPath("images.md")
        outputPath.writeText(markdownBuilder)
        config.prettyLogger.printlnSuccess(message = "Exported Container Images to: ${outputPath.absolutePathString()}")

        val softwareVersionsWithResourceMap = podContainerImages.flatMap { podContainerImage -> podContainerImage.discoveredVersions.map { it }}

        outputPath = config.imagesDirectoryPath("softwareversions.md")
        outputPath.writeText(DataSerializer.toMarkdownTable(softwareVersionsWithResourceMap))
        config.prettyLogger.printlnSuccess(message = "Software Version Info Written to: ${outputPath.absolutePathString()}")

        outputPath = config.imagesDirectoryPath("softwareversions.csv")
        outputPath.writeText(DataSerializer.toCsv(softwareVersionsWithResourceMap))
        config.prettyLogger.printlnSuccess(message = "Software Version Info Written to: ${outputPath.absolutePathString()}")

        outputPath = config.imagesDirectoryPath("softwareversions.json")
        outputPath.writeText(DataSerializer.toJson(softwareVersionsWithResourceMap))
        config.prettyLogger.printlnSuccess(message = "Software Version Info Written to: ${outputPath.absolutePathString()}")


    }

    fun getTags (history : MutableList<HistoryResponseItem>) : MutableList<String> {
        val tags = mutableListOf<String>()
        history.forEach {entry ->
            entry.tags?.forEach { tag ->
                tags.add(tag)
            }
        }
        return tags
    }

    fun getBuildHistory (history : MutableList<HistoryResponseItem>) = history.map {entry -> entry.createdBy }

    fun getEnvVars(inspect : ImageInspect) : Map<String,String> {
        val envVars = mutableMapOf<String, String>()
        inspect.config?.env?.forEach { env ->
            val parts = env.split("=", limit = 2)
            if (parts.size == 2) {
                envVars[parts[0]] = parts[1]
            }
        }

        return envVars
    }

    private fun checkSoftwareVersions(podContainerImage: PodContainerImage) {
        podContainerImage.discoveredVersions.forEach { packageVersion ->
            //val translationPair = endOfLifeproductVersionPair(packageVersion.name,packageVersion.source)
            //translationPair?.let { pair ->
            val versionChecker = ProductEOLChecker(packageVersion.name)
            if(versionChecker.productFound()) {
                packageVersion.isEndOfLife=versionChecker.hasReachedEOL(packageVersion.version)
                versionChecker.getLatestVersion(packageVersion.version)?.let { packageVersion.latestVersion = it }
                packageVersion.isOutOfDate = versionChecker.isOutOfDate(packageVersion.version)
                packageVersion.endOfLifeReference = versionChecker.getProductEOLLink()
                packageVersion.endOfLifeFound = true
            }

            //}
        }
    }

    private fun findBaseContainerImageAndVersion(
        podContainerImage: PodContainerImage,
        inspect: ImageInspect,
        history: MutableList<HistoryResponseItem>,
        inspectTags: MutableList<String>,
        envVars: Map<String, String>
    ) {


        podContainerImage.imageName.substringAfterLast("/").split(":").let {
            if(it.size == 2) {
                var baseImageName = it[0]
                var baseImageVersion = it[1]
                val errors = mutableListOf<String>()

                val search = versionRegex.find(it[1])
                if(search!=null) {
                    baseImageVersion=search.value
                }
                else {
                    errors.add("regex match group failed for image version ${versionRegex.toString()} -> ${it[1]}")
                }

                val pair = endOfLifeProductVersionPair(it[0],PackageVersionSource.IMAGE_NAME)
                if(pair!=null) {
                    baseImageName = pair.second
                }
                else {
                    errors.add("Product lookup failed for ${it[0]}")
                }

                if(versionRegex.containsMatchIn(baseImageVersion)) {
                    val pv = PackageVersion(
                        name = baseImageName,
                        version = baseImageVersion,
                        original = podContainerImage.imageName,
                        source = PackageVersionSource.IMAGE_NAME,
                        namespace = podContainerImage.namespace,
                        podName = podContainerImage.podName,
                        imageID = podContainerImage.imageID,
                        imageName = podContainerImage.imageName,
                    )
                    if(errors.isNotEmpty()) {
                        pv.errors.addAll(errors)
                    }
                    podContainerImage.discoveredVersions.add(pv)
                }
            }
        }

        inspectTags.forEach { imageName ->
            imageName.substringAfterLast("/").split(":").let {
                if(it.size == 2) {
                    var baseImageName = it[0]
                    var baseImageVersion = it[1]
                    val errors = mutableListOf<String>()

                    val search = versionRegex.find(it[1])
                    if(search!=null) {
                        baseImageVersion=search.value
                    }
                    else {
                        errors.add("regex match group failed for image version ${versionRegex.toString()} -> ${it[1]}")
                    }


                    val pair = endOfLifeProductVersionPair(it[0],PackageVersionSource.IMAGE_TAG)
                    if(pair!=null) {
                        baseImageName = pair.second
                    }
                    else {
                        errors.add("Product lookup failed: ${it[0]}")
                    }

                    if(versionRegex.containsMatchIn(baseImageVersion)) {
                        val pv = PackageVersion(
                            name = baseImageName,
                            version = baseImageVersion,
                            original = imageName,
                            source = PackageVersionSource.IMAGE_TAG,
                            namespace = podContainerImage.namespace,
                            podName = podContainerImage.podName,
                            imageID = podContainerImage.imageID,
                            imageName = podContainerImage.imageName,
                        )

                        if(errors.isNotEmpty()) {
                            pv.errors.addAll(errors)
                        }
                        podContainerImage.discoveredVersions.add(pv)
                    }
                }
            }
        }

        populateOpenContainerHistory(podContainerImage,history)
        history.forEach { entry ->
            entry.createdBy.let { historyItem ->
                var name = historyItem
                var version = historyItem
                val errors = mutableListOf<String>()

                val search = versionRegex.find(historyItem)
                if(search !=null) {
                    version=search.value
                }
                else {
                    errors.add("regex match group failed: ${versionRegex.toString()} -> ${entry.createdBy}")
                }

                val pair = endOfLifeProductVersionPair(historyItem,PackageVersionSource.BUILD_HISTORY)
                if(pair!=null) {
                    name = pair.second
                }
                else {
                    errors.add("Product lookup failed: $historyItem")
                }

                if(versionRegex.containsMatchIn(historyItem)) {
                    val pv = PackageVersion(
                        name = name,
                        version = version,
                        original = entry.createdBy,
                        source = PackageVersionSource.BUILD_HISTORY,
                        namespace = podContainerImage.namespace,
                        podName = podContainerImage.podName,
                        imageID = podContainerImage.imageID,
                        imageName = podContainerImage.imageName,
                    )
                    if(errors.isNotEmpty()) {
                        pv.errors.addAll(errors)
                    }
                    podContainerImage.discoveredVersions.add(pv)
                }
            }
        }

        envVars.forEach { (key, value) ->
            if(versionRegex.matches(value)) {
                var version = value
                var name = key
                val errors = mutableListOf<String>()

                val search = versionRegex.find(value)
                if(search!=null){
                    version=search.value
                }
                else {
                    errors.add("Regex match group failed: ${versionRegex.toString()} -> $value}")
                }

                val pair = endOfLifeProductVersionPair(key,PackageVersionSource.ENVIRONMENT_VARIABLE)
                if(pair!=null) {
                    name = pair.second
                }
                else {
                    errors.add("Product lookup failed: $key")
                }
                val pv = PackageVersion(
                    name = name,
                    version = version,
                    original = "$key=$value",
                    source = PackageVersionSource.ENVIRONMENT_VARIABLE,
                    namespace = podContainerImage.namespace,
                    podName = podContainerImage.podName,
                    imageID = podContainerImage.imageID,
                    imageName = podContainerImage.imageName,
                )

                if(errors.isNotEmpty()) {
                    pv.errors.addAll(errors)
                }
                podContainerImage.discoveredVersions.add(pv)
            }
        }
    }

    private fun populateOpenContainerHistory(
        podContainerImage: PodContainerImage,
        history: MutableList<HistoryResponseItem>
    ) {
        var productName = ""
        var productVersion = ""
        val productRegex = listOf(
            Regex("org\\.opencontainers\\.image\\.ref\\.name=([^ ]+)"),
            Regex("org\\.opencontainers\\.image\\.title=([^ ]+)"),
        )
        val versionRegex = Regex("org\\.opencontainers\\.image\\.version=[vV]?([^ ]+)")

        val allEntries = history.joinToString("\n") { entry -> entry.createdBy }
        val productSearch = productRegex.firstNotNullOfOrNull { regex ->  regex.find(allEntries) }
        if(productSearch!=null) {
            productName = productSearch.groupValues[1].lowercase()
        }

        val versionSearch = versionRegex.find(allEntries)
        if(versionSearch!=null) {
            productVersion = versionSearch.groupValues[1]
        }

        if(productName.isNotEmpty() && productVersion.isNotEmpty()) {
            val pv = PackageVersion(
                name = productName,
                version = productVersion,
                original = "OpenContainerHistory Info",
                source = PackageVersionSource.BUILD_HISTORY,
                namespace = podContainerImage.namespace,
                podName = podContainerImage.podName,
                imageID = podContainerImage.imageID,
                imageName = podContainerImage.imageName,
            )
            podContainerImage.discoveredVersions.add(pv)
        }
    }

}

enum class ContainerType(containerType : String) {
    CONTAINER("Container"),
    INIT_CONTAINER("InitContainer"),
    EPHEMERAL_CONTAINER("EphemeralContainer"),
    UNKNOWN("Unknown");
}
data class PodContainerImage(
    @CsvColumnMapping(name = "Namespace", order = 1)
    @JsonProperty("namespace")
    val namespace : String,

    @CsvColumnMapping(name = "Pod Name", order = 2)
    @JsonProperty("podName")
    val podName : String,

    @CsvColumnMapping(name = "Container Type", order = 3)
    @JsonProperty("containerType")
    val containerType : ContainerType,

    @CsvColumnMapping(name = "Creation Time", order = 4)
    @JsonProperty("podCreationTimestamp")
    val podCreationTimestamp : String?,

    @CsvColumnMapping(name = "Pod Phase", order = 5)
    @JsonProperty("podPhase")
    val podPhase: String,

    @CsvColumnMapping(name = "Image Name", order = 6)
    @JsonProperty("imageName")
    val imageName : String,

    @CsvColumnMapping(name = "Image ID", order = 7)
    @JsonProperty("imageID")
    val imageID: String,

    @CsvColumnMapping(name = "Tags", order = 8)
    @JsonProperty("imageTags")
    var imageTags: List<String>?,

    @CsvColumnMapping(name = "History", order = 9)
    @JsonProperty("buildHistory")
    var buildHistory: List<String>?,

    @CsvColumnMapping(name = "Environment Variables", order = 10)
    @JsonProperty("environmentVariables")
    var environmentVariables: Map<String,String>?,

    @CsvColumnMapping(name = "Discovered Versions", order = 11)
    @JsonProperty("discoveredVersions")
    var discoveredVersions: MutableList<PackageVersion> = mutableListOf<PackageVersion>(),

    ){
    fun filenamePrefix() : String {
        return "${namespace}_${podName}_${containerType}_${imageID.replace("/","_").replace("@","_").replace(":","_")}"
    }

    @CsvColumnMapping(name = "Has End Of Life Software", order = 12)
    @JsonProperty("hasEndOfLifeSoftware")
    val hasEndOfLifeSoftware = discoveredVersions.any { it.isEndOfLife == true }

    @CsvColumnMapping(name = "Has Outdated Software", order = 13)
    @JsonProperty("hasOutDatedSoftware")
    val hasOutDatedSoftware = discoveredVersions.any { it.isOutOfDate == true }
}

enum class PackageVersionSource(source : String) {
    ENVIRONMENT_VARIABLE("Environment Variable"),
    IMAGE_NAME("Image Name"),
    IMAGE_TAG("Image Tag"),
    BUILD_HISTORY("Build History"),
    UNKNOWN("Unknown");
}

data class PackageVersion(
    @CsvColumnMapping(name = "Name", order = 1)
    @JsonProperty("name")
    val name : String,

    @CsvColumnMapping(name = "Version", order = 2)
    @JsonProperty("version")
    val version : String,

    @CsvColumnMapping(name = "Original", order = 3)
    @JsonProperty("original")
    val original : String,

    @CsvColumnMapping(name = "Source", order = 4)
    @JsonProperty("source")
    val source : PackageVersionSource,

    @CsvColumnMapping(name = "Errors", order = 5)
    @JsonProperty("errors")
    var errors : MutableList<String> = mutableListOf(),

    @CsvColumnMapping(name = "Product Found in DB", order = 6)
    @JsonProperty("endOfLifeFound")
    var endOfLifeFound : Boolean = false,

    @CsvColumnMapping(name = "End of Life?", order = 7)
    @JsonProperty("isEndOfLife")
    var isEndOfLife : Boolean = false,

    @CsvColumnMapping(name = "is Out of Date", order = 8)
    @JsonProperty("isOutOfDate")
    var isOutOfDate : Boolean = false,

    @CsvColumnMapping(name = "Latest Version", order = 9)
    @JsonProperty("latestVersion")
    var latestVersion : String = "",

    @CsvColumnMapping(name = "End of Life Reference", order = 10)
    @JsonProperty("endOfLifeReference")
    var endOfLifeReference : String = "",

    @CsvColumnMapping(name = "Cluster Namespace", order = 11)
    @JsonProperty("namespace")
    var namespace : String = "",

    @CsvColumnMapping(name = "Pod Name", order = 12)
    @JsonProperty("pod")
    var podName : String = "",

    @CsvColumnMapping(name = "Image Name", order = 13)
    @JsonProperty("imageName")
    var imageName : String = "",

    @CsvColumnMapping(name = "Image ID", order = 14)
    @JsonProperty("imageID")
    var imageID : String = "",




)
