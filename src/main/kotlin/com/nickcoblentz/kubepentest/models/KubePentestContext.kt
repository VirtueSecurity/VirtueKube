package com.nickcoblentz.kubepentest.models

import com.nickcoblentz.kubepentest.utils.ImportExportUtils
import com.nickcoblentz.kubepentest.utils.PrettyLogger
import io.fabric8.kubernetes.client.Config
import io.fabric8.kubernetes.client.KubernetesClient
import io.fabric8.kubernetes.client.KubernetesClientBuilder
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.Path
import kotlin.io.path.absolutePathString

/**
 * Class to hold configuration and shared resources for the application.
 */
class KubePentestContext {
    var verbose: Boolean = true
    var kubeConfigPath: String = ""

    val prettyLogger: PrettyLogger = PrettyLogger()

    val k8s: KubernetesClient by lazy {

        prettyLogger.printlnMarkdown("### Using KubeConfig: ${Path(kubeConfigPath).absolutePathString()}, Exists: ${Files.exists(Path(kubeConfigPath))}")

        val client = if (kubeConfigPath.isBlank() || Files.notExists(Path(kubeConfigPath))) {
            prettyLogger.printlnWarning("Building empty Kubernetes client")
            KubernetesClientBuilder().build()
        } else {
            prettyLogger.printlnMarkdown("- Building Kubernetes client from config")
            val tempClient = KubernetesClientBuilder()
                .withConfig(Config.fromKubeconfig(Files.readString(Path(kubeConfigPath))))
                .build()
            prettyLogger.printlnMarkdownHelper(
                title="Kubectl Context: ${tempClient.configuration.currentContext.name}",
                subTitle = "",
        "Cluster: ${tempClient.configuration.currentContext.context.cluster}",
                "User: ${tempClient.configuration.currentContext.context.user}",
                "Default Namespace: ${tempClient.configuration.currentContext.context.namespace}")

            tempClient
        }



        client
    }

    val importExportUtils: ImportExportUtils by lazy {
        ImportExportUtils(k8s)
    }

    // Directory structure configuration
    var dataDirectoryBase = "output"
    var allDataDirectory = "all"
    var byNamespacedDataDirectory = "bynamespace"
    var byResourceDataDirectory = "byresource"
    var ipsDataDirectory = "ips"  // Renamed for consistency
    var allJSONFile = "all.json"
    var allYAMLFile = "all.yaml"
    var helmDirectory = "helm"
    var podLogsDirectory = "podlogs"
    var testCaseDirectory = "testCases"
    var testCaseResultsDirectory = "testCases"
    var nmapDirectory = "nmap"
    var gowitnessDirectory = "gowitness"
    var securityDirectory = "security"
    var imagesDirectory = "images"
    var tagDirectory = "containertags"
    var historyDirectory = "containerhistory"
    var envVarsDirectory = "containerenvvars"

    /**
     * Creates a path by combining the base directory with optional subdirectories and filename
     */
    private fun createPath(vararg parts: String): Path = Path(dataDirectoryBase, *parts)

    /**
     * Returns a path to the specified directory, optionally with a filename
     */
    private fun directoryPath(directory: String, filename: String? = null): Path = 
        if (filename.isNullOrEmpty()) createPath(directory) else createPath(directory, filename)

    // Path accessor methods
    fun dataDirectoryBasePath(filename: String? = null): Path =
        if (filename.isNullOrEmpty()) Path(dataDirectoryBase) else createPath(filename)

    fun allDataDirectoryPath(filename: String? = null): Path = directoryPath(allDataDirectory, filename)
    fun byNamespacedDataDirectoryPath(filename: String? = null): Path = directoryPath(byNamespacedDataDirectory, filename)
    fun byResourceDataDirectoryPath(filename: String? = null): Path = directoryPath(byResourceDataDirectory, filename)
    fun ipsDataDirectoryPath(filename: String? = null): Path = directoryPath(ipsDataDirectory, filename)
    fun allJSONFilePath(): Path = createPath(allJSONFile)
    fun allYAMLFilePath(): Path = createPath(allYAMLFile)
    fun helmDirectoryPath(filename: String? = null): Path = directoryPath(helmDirectory, filename)
    fun podLogsDirectoryPath(filename: String? = null): Path = directoryPath(podLogsDirectory, filename)
    fun testCaseDirectoryPath(filename: String? = null): Path = 
        if (filename.isNullOrEmpty()) Path(testCaseDirectory) else Path(testCaseDirectory, filename)
    fun nmapDirectoryPath(filename: String? = null): Path = directoryPath(nmapDirectory, filename)
    fun gowitnessDirectoryPath(filename: String? = null): Path = directoryPath(gowitnessDirectory, filename)
    fun securityDirectoryPath(filename: String? = null): Path = directoryPath(securityDirectory, filename)
    fun testCaseResultsDirectoryPath(filename: String? = null): Path = directoryPath(testCaseResultsDirectory, filename)
    fun imagesDirectoryPath(filename: String? = null): Path = directoryPath(imagesDirectory, filename)
    fun tagDirectoryPath(filename: String? = null): Path = directoryPath(tagDirectory, filename)
    fun historyDirectoryPath(filename: String? = null): Path = directoryPath(historyDirectory, filename)
    fun envVarsDirectoryPath(filename: String? = null): Path = directoryPath(envVarsDirectory, filename)

    /**
     * Returns a list of all directories that should be created
     */
    fun getAllDirectories(): List<Path> = listOf(
        dataDirectoryBasePath(),
        allDataDirectoryPath(),
        byNamespacedDataDirectoryPath(),
        byResourceDataDirectoryPath(),
        ipsDataDirectoryPath(),
        helmDirectoryPath(),
        podLogsDirectoryPath(),
        testCaseDirectoryPath(),
        nmapDirectoryPath(),
        gowitnessDirectoryPath(),
        securityDirectoryPath(),
        testCaseResultsDirectoryPath(),
        imagesDirectoryPath(),
        tagDirectoryPath(),
        historyDirectoryPath(),
        envVarsDirectoryPath()
    )


    fun ensureDirectoriesExist() {
        val directories = mutableListOf<String>()
        getAllDirectories().forEach {
            directories.add(it.absolutePathString())
            if (!Files.isDirectory(it)) {
                Files.createDirectory(it)
            }
        }

        prettyLogger.printlnMarkdownHelper(
            title = "Directories",
            subTitle="",
            *directories.toTypedArray()
        )
    }

}
